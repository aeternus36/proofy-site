<!doctype html>
<!-- VERIFY-HARDTEST v2026-01-19b / LOCKED 5/5 (audit-lock + fewer-clicks + overlay-safe + serverTimeUnix + block-evidence) -->
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Proofy – Verifiera underlag</title>
  <meta name="description" content="Kontroll av om ett underlag motsvarar en version som tidigare noterats i Proofys register." />
  <meta name="theme-color" content="#0b1220" />
  <meta name="robots" content="noindex" />

  <link rel="stylesheet" href="/assets/proofy.css?v=2026-01-03a" />
  <link rel="stylesheet" href="/assets/header.css?v=2026-01-03a" />

  <script src="/assets/qr.min.js?v=2026-01-03a"></script>

  <style>
    .sr-only{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }

    /*
      ✅ Hardtest: bottenutrymme så widget/overlay inte täcker innehåll.
      OBS: Ingen local override av --proofy-fab-space här (one source of truth).
      JS (overlaySafe) kan sätta --proofy-fab-space på :root vid behov.
    */
    main{
      padding-bottom: calc(140px + env(safe-area-inset-bottom, 0px) + var(--proofy-fab-space, 0px));
    }

    /* Visas endast vid behov (JS) */
    #idPill, #selfLinkPill, #statusPill, #copySummaryPill { display:none; }

    .actionsRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    .actionsMetaRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      margin-top:10px;
    }

    .selfLinkRow{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
      margin-top:10px;
    }
    #selfQRTap{
      width:184px;
      height:184px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:#ffffff;
      display:none;
      place-items:center;
      overflow:hidden;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    #selfQRCode{
      width:168px;
      height:168px;
      display:grid;
      place-items:center;
    }
    #selfQRCode canvas, #selfQRCode img, #selfQRCode svg{
      width:168px !important;
      height:168px !important;
      display:block;
      image-rendering: pixelated;
    }

    /* ✅ Liten “Avbryt” som riktig knapp */
    #abortBtn{ display:none; }

    /* ✅ Audit/version (neutral). Visas bara vid ?debug=1 */
    #auditVerifyVersion{
      display:none;
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      color:rgba(234,240,255,.78);
      font-size:12px;
      line-height:1.35;
    }
    #auditVerifyVersion .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:rgba(234,240,255,.92);
      word-break:break-word;
      overflow-wrap:anywhere;
    }

    /* ✅ Resultat: top actions (även “Hoppa till notering”) */
    .resultTopActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:12px;
    }

    /* ✅ Bevisstatus-ruta: tydlig separation mellan filresultat och registerstatus */
    .proofyEvidenceBox{
      margin-top:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
    }
    .proofyEvidenceGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (min-width: 921px){
      .proofyEvidenceGrid{ grid-template-columns: 1fr 1fr; }
    }

    /* ✅ Kontrolltid box (Proofy systemtid + enhet), revision-first */
    .proofyTimeBox{
      margin-top:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
    }
    .proofyTimeGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (min-width: 921px){
      .proofyTimeGrid{ grid-template-columns: 1fr 1fr; }
    }

    /* “Hoppa” ska kännas som knapp men utan att bli primär handling */
    .btn.jump{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(234,240,255,.92);
    }

    @media print{
      header, .actions, #chatWidget, #chat-widget, .mnav, .navActions { display:none !important; }
      #selfQRTap{ display:grid !important; border-color:#ddd !important; }
      #selfQRTap, #selfQRCode{ -webkit-print-color-adjust:exact; print-color-adjust:exact; }

      #auditVerifyVersion{
        border-color:#ddd !important;
        background:#fff !important;
        color:#111 !important;
      }
      #auditVerifyVersion .mono{ color:#000 !important; }
    }
  </style>
</head>

<body>
<a class="skip" href="#main">Hoppa till innehåll</a>

<header>
  <div class="wrap">
    <div class="nav">
      <a class="brand" href="/" aria-label="Proofy">
        <span class="logo" aria-hidden="true"></span>
        <span>Proofy</span>
      </a>

      <div class="navActions" id="navActionsDesktop">
        <a class="btn" href="/register.html">Skapa kontrollvärde</a>
        <a class="btn" href="/verify.html" aria-current="page">Verifiera underlag</a>
        <a class="btn" href="/pilot.html">Starta pilot</a>
        <a class="btn primary" href="/#kontakt">Boka kort demo</a>
      </div>

      <details class="mnav" id="mnav">
        <summary class="mnavSummary" aria-label="Öppna meny">
          <span class="mnavIcon" aria-hidden="true"></span>
        </summary>

        <nav class="mnavMenu" aria-label="Meny">
          <a class="mnavLink" href="/verify.html" aria-current="page">Verifiera underlag</a>
          <a class="mnavLink" href="/register.html">Skapa kontrollvärde</a>
          <a class="mnavLink" href="/pilot.html">Starta pilot</a>
          <a class="mnavLink mnavLinkPrimary" href="/#kontakt">Boka kort demo</a>

          <div class="mnavMeta">
            <a class="mnavLink" href="/security.html">Säkerhet</a>
            <a class="mnavLink" href="/privacy.html">Integritet</a>
            <a class="mnavLink" href="/terms.html">Villkor</a>
            <a class="mnavLink" href="/cookies.html">Cookies</a>

            <div class="mnavNote">Verifiering · revision · granskning</div>
            <a class="mnavMail" href="mailto:kontakt@proofy.se">kontakt@proofy.se</a>
          </div>
        </nav>
      </details>
    </div>
  </div>
</header>

<main id="main">
  <div class="wrap">
    <div class="badge">Verifiering · revision · granskning</div>

    <h1 class="pageTitle">Verifiera underlag</h1>

    <p class="lead">
      Kontrollera om ett underlag motsvarar samma filversion som tidigare <b>noterats i Proofys register</b>.
      <strong>Kontrollen sker lokalt. Underlaget lämnar inte din dator.</strong>
    </p>

    <p class="meta" style="margin-top:-6px; opacity:.9; max-width:92ch;">
      Proofy uttalar sig inte om dokumentets innehåll, riktighet, giltighet eller äkthet.
      Kontrollen avser endast filversion och registerstatus vid angivet kontrolltillfälle.
    </p>

    <div class="card content" style="margin-top:14px;">
      <div class="grid2">

        <section aria-label="Verifieringsuppgifter">
          <div style="font-weight:950; font-size:16px;">1. Ange Verifierings-ID</div>

          <label class="meta" for="hashInput" style="margin-top:8px;">Verifierings-ID (kontrollvärde)</label>
          <input id="hashInput" type="text" placeholder="0x…" autocomplete="off" spellcheck="false" style="margin-top:6px" />

          <div class="small" style="margin-top:8px">
            ID:t fylls i automatiskt om du öppnat sidan via verifieringslänk.
          </div>

          <div class="actions" style="margin-top:10px;">
            <div class="actionsRow">
              <button class="btn" id="pasteIdBtn" type="button">Klistra in ID</button>
              <button class="btn soft" id="clearIdBtn" type="button" disabled>Rensa</button>
            </div>

            <div class="actionsMetaRow">
              <span id="idPill" class="pill" aria-live="polite" aria-atomic="true" role="status"></span>
            </div>
          </div>

          <div class="hr"></div>

          <div style="font-weight:950; font-size:16px;">2. Välj underlag att kontrollera</div>

          <label for="fileInput" class="btn primary" style="display:inline-flex; margin-top:8px; cursor:pointer;">
            Välj underlag
          </label>
          <input id="fileInput" type="file" style="display:none;" />

          <div id="dropZone" class="drop" role="button" tabindex="0"
               aria-label="Dra och släpp underlag här, eller tryck för att välja fil"
               style="margin-top:10px;">
            Dra &amp; släpp underlag här<br />
            <span class="small" style="opacity:.9;">Tryck här för att välja underlag</span>
          </div>

          <div id="fileInfo"
               class="meta"
               style="margin-top:10px; padding:10px 12px; border-radius:12px; border:1px dashed rgba(255,255,255,.25); background:rgba(255,255,255,.04);">
            Inget underlag valt.
          </div>

          <div class="actions" style="margin-top:14px">
            <div class="actionsRow">
              <button class="btn soft" id="verifyBtn" disabled>Kontrollera</button>
              <button class="btn" id="abortBtn" type="button">Avbryt</button>
              <span id="statusPill" class="pill" role="status" aria-live="polite" aria-atomic="true">Förbered kontroll</span>
            </div>
          </div>

          <div id="inputAlert"
               role="status"
               aria-live="polite"
               style="display:none; margin-top:10px; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06);">
            <div id="inputAlertText" style="font-weight:800;"></div>
            <div id="inputAlertHelp" class="small" style="margin-top:6px; opacity:.95;"></div>
          </div>

          <p class="small" style="margin-top:12px; margin-bottom:0;">
            Resultatet kan skilja sig om underlaget har skapats om, sparats på nytt eller valts fel.
          </p>

          <div class="hr"></div>

          <div class="meta">Verifieringslänk (klicka för att kopiera)</div>
          <div class="small" style="margin-top:6px; opacity:.9;">Kan delas vid intern kontroll eller granskning.</div>

          <div class="selfLinkRow">
            <div style="flex:1; min-width:260px;">
              <div style="position:relative; margin-top:6px;">

                <!-- Ikonknapp borttagen (minskar dubbelkopiering). Klick på fältet kopierar. -->
                <button type="button" id="copySelfLinkIconBtn"
                  aria-label="Kopiera verifieringslänk" title="Kopiera"
                  style="display:none; position:absolute; top:6px; right:6px; width:34px; height:30px;
                         border-radius:10px; border:1px solid rgba(255,255,255,.14);
                         background:rgba(255,255,255,.06); cursor:pointer;">
                  <span aria-hidden="true" style="display:block; font-size:15px; line-height:28px;">⧉</span>
                </button>

                <div id="selfLinkOut"
                  class="mono"
                  tabindex="0"
                  role="button"
                  title="Klicka för att kopiera"
                  aria-label="Verifieringslänk (klicka för att kopiera)"
                  style="
                    padding:8px 10px;
                    border-radius:12px;
                    border:1px solid rgba(255,255,255,.14);
                    background:rgba(255,255,255,.03);
                    cursor:pointer;
                    padding-right:10px;
                    user-select:text;
                    overflow-wrap:anywhere;
                    word-break:break-word;
                    font-size:13px;
                    line-height:1.3;
                  ">—</div>

                <span id="selfLinkPill" class="pill" style="margin-top:8px;" aria-live="polite" aria-atomic="true" role="status"></span>
              </div>

              <div class="small" id="selfQRHelp" style="margin-top:10px; opacity:.9; display:none;">
                Skanna med <b>annan enhet</b> för snabb kontroll. Klick på QR kopierar länken.
              </div>
            </div>

            <div id="selfQRTap"
                 role="button"
                 tabindex="0"
                 aria-label="QR-kod (klicka för att kopiera verifieringslänken)"
                 title="Klicka för att kopiera verifieringslänken">
              <div id="selfQRCode" aria-label="QR-kod"></div>
            </div>
          </div>

        </section>

        <section aria-label="Resultat">
          <div style="display:flex; align-items:baseline; justify-content:space-between; gap:12px;">
            <div style="font-weight:950; font-size:16px;">Resultat</div>
            <div class="meta" id="reportMeta" style="opacity:.85; display:none;">Rapport</div>
          </div>
          <div class="hr"></div>

          <div id="resultBox" style="display:none;">
            <div id="resultHeadline"
                 style="font-size:18px; font-weight:950; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.05);">
            </div>

            <!-- ✅ Kontrolltid (Proofy systemtid + enhet) -->
            <div class="proofyTimeBox" role="status" aria-live="polite" aria-atomic="true">
              <div class="meta">Kontrolltid vid kontrolltillfället</div>

              <div class="proofyTimeGrid">
                <div>
                  <div class="meta" style="opacity:.9;">Proofy (från serversvar)</div>
                  <div id="outCheckedServerSe" class="mono" style="margin-top:6px;">—</div>
                  <div id="outCheckedServerUtc" class="mono" style="margin-top:6px; opacity:.75;">—</div>
                </div>

                <div>
                  <div class="meta" style="opacity:.9;">Enhet (kompletterande)</div>
                  <div id="outCheckedDeviceSe" class="mono" style="margin-top:6px;">—</div>
                  <div id="outCheckedDeviceUtc" class="mono" style="margin-top:6px; opacity:.75;">—</div>
                </div>
              </div>

              <div class="small" style="margin-top:10px; opacity:.9;">
                Proofy-tid kommer från serversvaret (<span class="mono">serverTimeUnix</span>). Ingen av tiderna utgör extern tidsstämpling.
                Enhetstid kan vara fel om systemklockan är fel.
              </div>

              <div class="small" id="httpDateLine" style="margin-top:10px; opacity:.82; display:none;">
                HTTP Date (transport, kompletterande): <span class="mono" id="httpDateOut">—</span>
              </div>
            </div>

            <!-- ✅ Bevisstatus-ruta (registerstatus vid kontrolltillfället) -->
            <div class="proofyEvidenceBox" role="status" aria-live="polite" aria-atomic="true">
              <div class="meta">Bevisstatus vid kontrolltillfället (registerstatus)</div>

              <div class="proofyEvidenceGrid">
                <div>
                  <div class="meta" style="opacity:.9;">Status</div>
                  <div id="outRegStatus" class="mono" style="margin-top:6px;">—</div>
                </div>
                <div>
                  <div class="meta" style="opacity:.9;">Tidpunkt (endast om bekräftad)</div>
                  <div id="outRegSe" class="mono" style="margin-top:6px;">—</div>
                  <div id="outRegUtc" class="mono" style="margin-top:6px; opacity:.75; display:none;">—</div>
                </div>

                <!-- ✅ Block-evidence (revisionsstöd) -->
                <div>
                  <div class="meta" style="opacity:.9;">Registerblock (endast om bekräftad)</div>
                  <div id="outRegisteredBlock" class="mono" style="margin-top:6px;">—</div>

                  <div class="meta" style="opacity:.9; margin-top:10px;">Observerat block (RPC, valfritt)</div>
                  <div id="outObservedBlock" class="mono" style="margin-top:6px;">—</div>
                </div>
              </div>

              <div style="margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06);">
                <div class="small" style="line-height:1.45;">
                  <div><b>Avser:</b> Filversion (Verifierings-ID) och registerstatus vid kontrolltillfället.</div>
                  <div style="margin-top:6px;"><b>Avser inte:</b> Dokumentets innehåll, riktighet, giltighet eller äkthet.</div>
                </div>
              </div>
            </div>

            <!-- ✅ Primära åtgärder -->
            <div class="resultTopActions" aria-label="Primära åtgärder">
              <button class="btn primary" id="copySummaryBtn" type="button" style="display:none;">Kopiera notering</button>
              <a class="btn soft" id="openCertBtn" href="/certificate.html" style="display:none;">Öppna intyg</a>
              <button class="btn soft" id="downloadReportBtn" type="button" style="display:none;">Spara notering som textfil</button>
              <button class="btn jump" id="jumpToNoteBtn" type="button" style="display:none;">Hoppa till notering</button>
            </div>

            <div class="small" id="downloadHint" style="display:none; margin-top:8px; opacity:.85;">
              Filnamn: <span class="mono">proofy-notering.txt</span>
            </div>

            <div id="auditVerifyVersion">
              <div class="meta" style="opacity:.9;">Systemversion (verify.html)</div>
              <div class="mono" id="auditVerifyVersionValue">—</div>
            </div>

            <div id="outExplain"
                 style="margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06);">
              <div id="outExplainTitle" style="font-weight:900;"></div>
              <div id="outExplainBody" class="small" style="margin-top:6px; opacity:.95;"></div>
            </div>

            <p class="meta" style="margin-top:14px; opacity:.9;">
              Proofy uttalar sig inte om dokumentets innehåll, riktighet, giltighet eller äkthet.
              Kontrollen avser endast filversion och registerstatus vid angivet kontrolltillfälle.
            </p>

            <div class="hr" style="margin-top:14px;"></div>

            <div id="noteAnchor" style="height:1px;"></div>

            <div class="meta">Notering (för ärendeakt)</div>
            <pre class="mono" id="summaryOut" style="white-space:pre-wrap; margin-top:8px;">—</pre>

            <div class="actions" style="margin-top:12px;">
              <div class="actionsMetaRow">
                <span id="copySummaryPill" class="pill" aria-live="polite" aria-atomic="true" role="status"> </span>
              </div>
            </div>
          </div>

          <div id="errorBox" style="display:none;">
            <div class="err">Kontrollen kunde inte genomföras</div>
            <div id="errorMsg" class="mono" style="margin-top:8px"></div>
          </div>
        </section>

      </div>
    </div>
  </div>
</main>

<footer>
  <div class="wrap">
    <div class="foot">
      <div>
        <div style="color: rgba(234,240,255,.86); font-weight:800;">Proofy</div>
        <div class="small">© 2026 Proofy. Alla rättigheter förbehållna.</div>
        <div class="small" style="margin-top:8px; max-width:92ch;">
          Proofy tillhandahåller teknisk kontroll av filversioner. Tjänsten utgör inte juridisk rådgivning och avgör inte dokumentets giltighet.
        </div>
      </div>
      <div class="links">
        <a href="/security.html">Säkerhet</a>
        <a href="/privacy.html">Integritet</a>
        <a href="/terms.html">Villkor</a>
        <a href="/cookies.html">Cookies</a>
        <a href="/#kontakt">Kontakt</a>
      </div>
    </div>
  </div>
</footer>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ✅ LOCKED build/version (neutral). Visas bara vid ?debug=1
  const PROOFY_VERIFY_BUILD = "VERIFY-HARDTEST v2026-01-19b / LOCKED 5/5";

  // --------- Hardtest: bind once ----------
  const BIND_KEY = "__proofy_verify_bound";
  if (document.documentElement.dataset[BIND_KEY] === "1") return;
  document.documentElement.dataset[BIND_KEY] = "1";

  const urlInit = new URL(location.href);
  const DEBUG = urlInit.searchParams.get("debug") === "1";

  // ✅ Propagera ev. tx från länkar (för registerkedja / cert)
  const initialTx = (urlInit.searchParams.get("tx") || "").trim();

  const hashInput = $("hashInput");
  const pasteIdBtn = $("pasteIdBtn");
  const clearIdBtn = $("clearIdBtn");
  const idPill = $("idPill");

  const selfLinkOut = $("selfLinkOut");
  const copySelfLinkIconBtn = $("copySelfLinkIconBtn"); // intentionally unused (kept hidden)
  const selfLinkPill = $("selfLinkPill");

  const selfQRTap = $("selfQRTap");
  const selfQRCode = $("selfQRCode");
  const selfQRHelp = $("selfQRHelp");

  const fileInput = $("fileInput");
  const dropZone = $("dropZone");
  const fileInfo = $("fileInfo");
  const verifyBtn = $("verifyBtn");
  const abortBtn = $("abortBtn");
  const statusPill = $("statusPill");

  const inputAlert = $("inputAlert");
  const inputAlertText = $("inputAlertText");
  const inputAlertHelp = $("inputAlertHelp");

  const reportMeta = $("reportMeta");

  const resultBox = $("resultBox");
  const resultHeadline = $("resultHeadline");

  // ✅ Kontrolltid: Proofy systemtid + enhet
  const outCheckedServerSe = $("outCheckedServerSe");
  const outCheckedServerUtc = $("outCheckedServerUtc");
  const outCheckedDeviceSe = $("outCheckedDeviceSe");
  const outCheckedDeviceUtc = $("outCheckedDeviceUtc");

  const httpDateLine = $("httpDateLine");
  const httpDateOut = $("httpDateOut");

  // ✅ Bevisstatus-ruta (registerstatus)
  const outRegStatus = $("outRegStatus");
  const outRegSe = $("outRegSe");
  const outRegUtc = $("outRegUtc");

  // ✅ Block-evidence (revisionsstöd)
  const outRegisteredBlock = $("outRegisteredBlock");
  const outObservedBlock = $("outObservedBlock");

  const openCertBtn = $("openCertBtn");

  const outExplain = $("outExplain");
  const outExplainTitle = $("outExplainTitle");
  const outExplainBody = $("outExplainBody");

  const copySummaryBtn = $("copySummaryBtn");
  const copySummaryPill = $("copySummaryPill");
  const summaryOut = $("summaryOut");
  const downloadReportBtn = $("downloadReportBtn");
  const downloadHint = $("downloadHint");

  const jumpToNoteBtn = $("jumpToNoteBtn");
  const noteAnchor = $("noteAnchor");

  const auditVerifyVersion = $("auditVerifyVersion");
  const auditVerifyVersionValue = $("auditVerifyVersionValue");

  const errorBox = $("errorBox");
  const errorMsg = $("errorMsg");

  let currentFile = null;
  let busy = false;
  let opId = 0;
  let lastRun = null;

  // ✅ Färre klick: autostart när ID+fil finns (men bara en gång per kombination)
  let lastAutoKey = "";

  // ✅ Abort fetch
  let fetchAbort = null;

  function isValidId(h){
    return /^0x[0-9a-fA-F]{64}$/.test((h || "").trim());
  }

  function showPill(el, text, ms = 1400){
    if (!el) return;
    el.style.display = "inline-block";
    el.textContent = text || "";
    setTimeout(() => {
      el.style.display = "none";
      el.textContent = "";
    }, ms);
  }

  async function copyTextToClipboard(text){
    const t = String(text || "").trim();
    if (!t || t === "—") return false;

    try{
      await navigator.clipboard.writeText(t);
      return true;
    } catch {
      try{
        const ta = document.createElement("textarea");
        ta.value = t;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top = "0";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand("copy");
        document.body.removeChild(ta);
        return !!ok;
      } catch {
        return false;
      }
    }
  }

  function setStatus(text){
    statusPill.textContent = text;
    statusPill.style.display = "inline-flex";
  }

  function setVerifyBtnTone(isReady){
    if (!verifyBtn) return;
    verifyBtn.classList.remove("primary");
    verifyBtn.classList.remove("soft");
    verifyBtn.classList.add(isReady ? "primary" : "soft");
  }

  function showAlert(title, help, tone){
    inputAlert.style.display = "block";
    inputAlertText.textContent = title || "";
    inputAlertHelp.textContent = help || "";

    if (tone === "err") {
      inputAlert.style.borderColor = "rgba(255,80,80,.35)";
      inputAlert.style.background = "rgba(255,80,80,.10)";
      inputAlertText.style.color = "rgba(255,220,220,.95)";
    } else if (tone === "ok") {
      inputAlert.style.borderColor = "rgba(80,255,180,.28)";
      inputAlert.style.background = "rgba(80,255,180,.08)";
      inputAlertText.style.color = "rgba(220,255,245,.95)";
    } else {
      inputAlert.style.borderColor = "rgba(255,255,255,.14)";
      inputAlert.style.background = "rgba(255,255,255,.06)";
      inputAlertText.style.color = "";
    }
  }

  function hideAlert(){
    inputAlert.style.display = "none";
    inputAlertText.textContent = "";
    inputAlertHelp.textContent = "";
  }

  function bytesToHex(bytes){
    return [...bytes].map(b => b.toString(16).padStart(2,"0")).join("");
  }

  async function makeControlValue(file){
    const buf = await file.arrayBuffer();
    const dig = await crypto.subtle.digest("SHA-256", buf);
    return "0x" + bytesToHex(new Uint8Array(dig));
  }

  function isoUtcNoMs(d){
    return d.toISOString().replace("T"," ").replace(/\.\d{3}Z$/, " UTC");
  }

  function fmtSeEpoch(epoch){
    try{
      return new Intl.DateTimeFormat("sv-SE", {
        timeZone:"Europe/Stockholm",
        year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(new Date(Number(epoch) * 1000)) + " (Europe/Stockholm)";
    } catch {
      return "—";
    }
  }

  function fmtUtcEpoch(epoch){
    try{
      return isoUtcNoMs(new Date(Number(epoch) * 1000));
    } catch {
      return "—";
    }
  }

  function formatUnixSe(unixSeconds){
    const n = Number(unixSeconds);
    if (!Number.isFinite(n) || n <= 0) return null;
    try{
      return new Intl.DateTimeFormat("sv-SE", {
        timeZone:"Europe/Stockholm",
        year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(new Date(n * 1000));
    } catch {
      return null;
    }
  }

  // ✅ Språklås: exakt 4 canonical statusuttryck
  function canonicalStatusFromCode(statusCode){
    const sc = String(statusCode || "");
    if (sc === "CONFIRMED") return "Bekräftad";
    if (sc === "SUBMITTED_UNCONFIRMED") return "Inskickad – ej bekräftad";
    if (sc === "NOT_CONFIRMED") return "Ej bekräftad";
    return "Kunde inte kontrolleras";
  }

  function normalizeVerifyModel(data){
    const sc = String(data?.statusCode || "");
    const legal = String(data?.legalText || "");
    const confirmedAtUnix = (data?.confirmedAtUnix != null) ? Number(data.confirmedAtUnix) : null;

    // Strikt: bara de fyra statuskoderna accepteras.
    if (sc !== "CONFIRMED" && sc !== "SUBMITTED_UNCONFIRMED" && sc !== "NOT_CONFIRMED" && sc !== "UNKNOWN") {
      return { statusCode:"UNKNOWN", legalText: legal, confirmedAtUnix: null };
    }

    return {
      statusCode: sc,
      legalText: legal,
      confirmedAtUnix: Number.isFinite(confirmedAtUnix) && confirmedAtUnix > 0 ? confirmedAtUnix : null,
      serverTimeUnix: (data?.serverTimeUnix != null) ? Number(data.serverTimeUnix) : null,
      requestId: String(data?.requestId || "").trim()
    };
  }

  // --------- Hardtest: timeout + retryable fetch ----------
  function isRetryableStatus(status){
    return status === 408 || status === 425 || status === 429 || (status >= 500 && status <= 599);
  }

  async function fetchJsonWithTimeout(url, timeoutMs = 20000, signal){
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), timeoutMs);
    const onAbort = () => controller.abort();

    try{
      if (signal) {
        if (signal.aborted) controller.abort();
        else signal.addEventListener("abort", onAbort, { once:true });
      }

      const r = await fetch(url, { method:"GET", cache:"no-store", signal: controller.signal, credentials:"same-origin" });
      const j = await r.json().catch(() => ({}));
      const dateHeader = r?.headers?.get ? (r.headers.get("Date") || "") : "";
      return { ok: r.ok, status: r.status, data: j, aborted:false, dateHeader };
    } catch (e){
      const aborted = (e && e.name === "AbortError");
      return { ok:false, status:0, data:{}, aborted, dateHeader:"" };
    } finally {
      clearTimeout(t);
      try { if (signal) signal.removeEventListener("abort", onAbort); } catch {}
    }
  }

  async function fetchVerify(id, tx, signal){
    const base = `/api/verify?hash=${encodeURIComponent(id)}${tx ? `&tx=${encodeURIComponent(tx)}` : ""}&t=${Date.now()}`;
    const attempts = 3;
    const baseDelay = 520;

    for (let i=0; i<attempts; i++){
      const res = await fetchJsonWithTimeout(base, 20000, signal);

      if (res.ok) return { ok:true, data:res.data, status:res.status, dateHeader: res.dateHeader };

      const retryable = res.aborted || isRetryableStatus(res.status);
      if (signal && signal.aborted) return { ok:false, data:{}, status:0, dateHeader:"" };

      if (i < attempts - 1 && retryable){
        const jitter = Math.floor(Math.random()*180);
        await new Promise(r => setTimeout(r, baseDelay*(i+1) + jitter));
        continue;
      }

      return { ok:false, data:res.data, status:res.status, dateHeader: res.dateHeader };
    }

    return { ok:false, data:{}, status:0, dateHeader:"" };
  }

  function setParamsInUrl({ hash, checked, tx }){
    const url = new URL(location.href);

    if (hash) {
      url.searchParams.set("hash", hash);
      url.searchParams.delete("id");
    } else {
      url.searchParams.delete("hash");
      url.searchParams.delete("id");
    }

    if (checked) url.searchParams.set("checked", String(checked));
    else url.searchParams.delete("checked");

    if (tx) url.searchParams.set("tx", String(tx));
    else url.searchParams.delete("tx");

    if (DEBUG) url.searchParams.set("debug", "1");
    else url.searchParams.delete("debug");

    history.replaceState({}, "", url.toString());
  }

  function buildSelfLink(id, checkedEpoch, tx){
    const u = new URL(`${location.origin}/verify.html`);
    u.searchParams.set("hash", id);
    if (checkedEpoch) u.searchParams.set("checked", String(checkedEpoch));
    if (tx) u.searchParams.set("tx", String(tx));
    if (DEBUG) u.searchParams.set("debug", "1");
    return u.toString();
  }

  function buildCertLink(id, checkedEpoch, tx){
    const u = new URL(`${location.origin}/certificate.html`);
    u.searchParams.set("hash", id);
    if (checkedEpoch) u.searchParams.set("checked", String(checkedEpoch));
    if (tx) u.searchParams.set("tx", String(tx));
    if (DEBUG) u.searchParams.set("debug", "1");
    return u.toString();
  }

  async function copyWithPill({ text, pillEl, okText="Kopierad ✓", failText="Kunde inte kopiera" }){
    if (!pillEl) return false;

    const t = String(text || "").trim();
    if (!t || t === "—") return false;

    pillEl.style.display = "inline-block";
    pillEl.textContent = "Kopierar…";
    const ok = await copyTextToClipboard(t);
    pillEl.textContent = ok ? okText : failText;

    setTimeout(() => {
      pillEl.style.display = "none";
      pillEl.textContent = "";
    }, 1400);

    return ok;
  }

  function downloadTextFile(filename, text){
    const blob = new Blob([String(text || "")], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function renderSelfQR(link){
    if (!selfQRCode || !selfQRTap) return;

    const el = selfQRCode;
    el.innerHTML = "";

    const payload = String(link || "").trim();

    const setFallback = (msg) => {
      el.innerHTML =
        '<div class="small" style="padding:10px;color:#0b1220;text-align:center;line-height:1.35">' +
        msg +
        "</div>";
    };

    if (!payload){
      selfQRTap.style.display = "none";
      if (selfQRHelp) selfQRHelp.style.display = "none";
      return;
    }

    selfQRTap.style.display = "grid";
    if (selfQRHelp) selfQRHelp.style.display = "block";

    if (typeof window.QRCode !== "function"){
      setFallback("QR kunde inte visas.");
      return;
    }

    const correctLevel =
      (window.QRCodeCorrectLevel && window.QRCodeCorrectLevel.H != null) ? window.QRCodeCorrectLevel.H :
      (window.QRCode && window.QRCode.CorrectLevel && window.QRCode.CorrectLevel.H != null) ? window.QRCode.CorrectLevel.H :
      undefined;

    try{
      let qr = null;

      try{
        qr = new window.QRCode(el);
        if (qr && qr._htOption){
          qr._htOption.width = 168;
          qr._htOption.height = 168;
          qr._htOption.colorDark = "#0b1220";
          qr._htOption.colorLight = "#ffffff";
          if (correctLevel != null) qr._htOption.correctLevel = correctLevel;
        }
      }catch{
        qr = null;
      }

      if (!qr || typeof qr.makeCode !== "function"){
        el.innerHTML = "";
        const opts = {
          width: 168,
          height: 168,
          colorDark: "#0b1220",
          colorLight: "#ffffff",
          correctLevel: correctLevel
        };
        qr = new window.QRCode(el, opts);
      }

      if (!qr || typeof qr.makeCode !== "function"){
        setFallback("QR kunde inte visas.");
        return;
      }

      qr.makeCode(payload);

      const node = el.querySelector("canvas, img, svg, table");
      if (!node){
        setFallback("QR kunde inte visas.");
        return;
      }

      node.style.width = "168px";
      node.style.height = "168px";
      node.style.display = "block";
      node.style.imageRendering = "pixelated";
    }catch{
      setFallback("QR kunde inte visas.");
    }
  }

  async function readClipboardText(){
    try{
      if (navigator.clipboard && navigator.clipboard.readText) {
        return await navigator.clipboard.readText();
      }
    } catch {}
    return "";
  }

  function resetUI(){
    resultBox.style.display = "none";
    errorBox.style.display = "none";
    errorMsg.textContent = "";
    if (openCertBtn) openCertBtn.style.display = "none";
    if (reportMeta) { reportMeta.style.display = "none"; reportMeta.textContent = "Rapport"; }

    if (copySummaryBtn) copySummaryBtn.style.display = "none";
    if (copySummaryPill) copySummaryPill.style.display = "none";
    if (downloadReportBtn) downloadReportBtn.style.display = "none";
    if (downloadHint) downloadHint.style.display = "none";
    if (jumpToNoteBtn) jumpToNoteBtn.style.display = "none";

    if (summaryOut) summaryOut.textContent = "—";
    lastRun = null;

    outRegStatus.textContent = "—";
    outRegSe.textContent = "—";
    outRegUtc.textContent = "—";
    outRegUtc.style.display = "none";

    if (outRegisteredBlock) outRegisteredBlock.textContent = "—";
    if (outObservedBlock) outObservedBlock.textContent = "—";

    if (outCheckedServerSe) outCheckedServerSe.textContent = "—";
    if (outCheckedServerUtc) outCheckedServerUtc.textContent = "—";
    if (outCheckedDeviceSe) outCheckedDeviceSe.textContent = "—";
    if (outCheckedDeviceUtc) outCheckedDeviceUtc.textContent = "—";

    if (httpDateLine) httpDateLine.style.display = "none";
    if (httpDateOut) httpDateOut.textContent = "—";

    if (auditVerifyVersion) auditVerifyVersion.style.display = "none";
    if (auditVerifyVersionValue) auditVerifyVersionValue.textContent = "—";

    resultHeadline.textContent = "";
    outExplainTitle.textContent = "";
    outExplainBody.textContent = "";
    setExplainTone(null);
  }

  function setBusy(v){
    busy = v;

    if (abortBtn) abortBtn.style.display = v ? "inline-flex" : "none";

    verifyBtn.disabled = v || !(currentFile && isValidId(hashInput.value));
    setVerifyBtnTone(!verifyBtn.disabled);

    if (v) {
      verifyBtn.textContent = "Kontrollerar…";
    } else {
      verifyBtn.textContent = lastRun ? "Kontrollera igen" : "Kontrollera";
    }
  }

  function setExplainTone(match){
    if (!outExplain) return;
    if (match === true) {
      outExplain.style.borderColor = "rgba(80,255,180,.22)";
      outExplain.style.background = "rgba(80,255,180,.07)";
      return;
    }
    if (match === false) {
      outExplain.style.borderColor = "rgba(255,80,80,.22)";
      outExplain.style.background = "rgba(255,80,80,.07)";
      return;
    }
    outExplain.style.borderColor = "rgba(255,255,255,.14)";
    outExplain.style.background = "rgba(255,255,255,.06)";
  }

  function setResultHeadline(match){
    resultHeadline.textContent = "";
    const left = document.createElement("span");
    const right = document.createElement("span");
    right.className = "meta";

    if (match) {
      left.className = "ok";
      left.textContent = "✅ Oförändrat";
      right.textContent = "(samma filversion)";
      resultHeadline.style.borderColor = "rgba(80,255,180,.20)";
      resultHeadline.style.background = "rgba(80,255,180,.06)";
    } else {
      left.className = "err";
      left.textContent = "⚠️ Ändrat";
      right.textContent = "(annan filversion)";
      resultHeadline.style.borderColor = "rgba(255,80,80,.20)";
      resultHeadline.style.background = "rgba(255,80,80,.06)";
    }

    resultHeadline.appendChild(left);
    resultHeadline.appendChild(document.createTextNode(" "));
    resultHeadline.appendChild(right);
  }

  function updateSelfLinkUI(){
    const id = (hashInput.value || "").trim();
    const ok = isValidId(id);

    if (!selfLinkOut) return;

    if (!ok){
      selfLinkOut.textContent = "—";
      renderSelfQR("");
      return;
    }

    const u = new URL(location.href);
    const checked = (u.searchParams.get("checked") || "").trim();
    const tx = (u.searchParams.get("tx") || initialTx || "").trim();

    const link = buildSelfLink(id, checked || "", tx || "");
    selfLinkOut.textContent = link;
    renderSelfQR(link);
  }

  function updateValidationUI(){
    const id = (hashInput.value || "").trim();
    const okId = isValidId(id);

    if (clearIdBtn) clearIdBtn.disabled = !id;
    updateSelfLinkUI();

    if (!id && !currentFile){
      hideAlert();
      setStatus("Förbered kontroll");
      setBusy(false);
      return;
    }

    if (!id){
      showAlert(
        "⚠️ Ange Verifierings-ID för att kunna kontrollera",
        "Klistra in Verifierings-ID eller öppna verifieringslänken du fått.",
        "err"
      );
      setStatus("Ange Verifierings-ID");
      setBusy(false);
      return;
    }

    if (!okId){
      showAlert(
        "⚠️ Verifierings-ID verkar inte stämma",
        "Kontrollera att du kopierat hela Verifierings-ID:t utan att något saknas.",
        "err"
      );
      setStatus("Åtgärd krävs");
      setBusy(false);
      return;
    }

    hideAlert();

    if (!currentFile) {
      setStatus("Välj underlag");
      setBusy(false);
      return;
    }

    setStatus("Redo");
    setBusy(false);

    const autoKey = `${id.toLowerCase()}::${currentFile.name}::${currentFile.size}::${currentFile.lastModified}`;
    if (autoKey !== lastAutoKey && !busy) {
      lastAutoKey = autoKey;
      setTimeout(() => {
        if (!busy && currentFile && isValidId(hashInput.value)) verifyNow({ auto:true });
      }, 0);
    }
  }

  function setFile(file){
    currentFile = file || null;
    if (currentFile){
      fileInfo.textContent = `Valt underlag: ${currentFile.name}`;
    } else {
      fileInfo.textContent = "Inget underlag valt.";
    }
    updateValidationUI();
  }

  // --------- URL init ----------
  const urlId = (() => {
    const url = new URL(location.href);
    return (url.searchParams.get("hash") || url.searchParams.get("id") || "").trim();
  })();

  if (isValidId(urlId)) {
    hashInput.value = urlId;
    const u = new URL(location.href);
    const existingChecked = (u.searchParams.get("checked") || "").trim();
    const existingTx = (u.searchParams.get("tx") || initialTx || "").trim();
    setParamsInUrl({ hash: urlId, checked: existingChecked || "", tx: existingTx || "" });
  }

  // --------- Handlers ----------
  if (pasteIdBtn){
    pasteIdBtn.addEventListener("click", async () => {
      const txt = (await readClipboardText()).trim();
      if (!txt){
        showPill(idPill, "Inget i urklipp");
        return;
      }
      const m = txt.match(/0x[0-9a-fA-F]{64}/);
      const candidate = (m ? m[0] : txt).trim();
      hashInput.value = candidate;

      const u = new URL(location.href);
      const checked = (u.searchParams.get("checked") || "").trim();
      const tx = (u.searchParams.get("tx") || initialTx || "").trim();

      if (isValidId(candidate)) {
        setParamsInUrl({ hash: candidate, checked: checked || "", tx: tx || "" });
        showPill(idPill, "Klistrat ✓");
      } else {
        showPill(idPill, "Klistrat (kontrollera att du fått med hela)");
      }

      updateValidationUI();
      hashInput.focus();
      hashInput.setSelectionRange(hashInput.value.length, hashInput.value.length);
    });
  }

  if (clearIdBtn){
    clearIdBtn.addEventListener("click", () => {
      hashInput.value = "";
      setParamsInUrl({ hash: "", checked: "", tx: "" });
      showPill(idPill, "Rensat");
      updateValidationUI();
      hashInput.focus();
    });
  }

  if (selfLinkOut){
    selfLinkOut.addEventListener("click", async () => {
      await copyWithPill({ text: selfLinkOut.textContent, pillEl: selfLinkPill, okText:"Länk kopierad ✅" });
    });
    selfLinkOut.addEventListener("keydown", async (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        await copyWithPill({ text: selfLinkOut.textContent, pillEl: selfLinkPill, okText:"Länk kopierad ✅" });
      }
    });
  }

  if (selfQRTap){
    const doQrCopy = async () => {
      const link = String(selfLinkOut?.textContent || "").trim();
      if (!link || link === "—") return;
      await copyWithPill({ text: link, pillEl: selfLinkPill, okText:"Länk kopierad ✅" });
    };
    selfQRTap.addEventListener("click", (e) => { e.preventDefault(); doQrCopy(); });
    selfQRTap.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); doQrCopy(); }
    });
  }

  // ✅ Hoppa till notering
  if (jumpToNoteBtn){
    jumpToNoteBtn.addEventListener("click", () => {
      try{
        (noteAnchor || summaryOut)?.scrollIntoView({ block:"start", behavior:"auto" });
      } catch {
        location.hash = "#noteAnchor";
      }
    });
  }

  hashInput.addEventListener("input", () => {
    const v = hashInput.value.trim();
    const u = new URL(location.href);
    const checked = (u.searchParams.get("checked") || "").trim();
    const tx = (u.searchParams.get("tx") || initialTx || "").trim();
    if (isValidId(v)) setParamsInUrl({ hash: v, checked: checked || "", tx: tx || "" });
    updateValidationUI();
  });

  fileInput.addEventListener("change", () => setFile(fileInput.files?.[0] || null));

  if (dropZone){
    dropZone.addEventListener("click", () => fileInput.click());
    dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); fileInput.click(); }
    });

    dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag"); });
    dropZone.addEventListener("dragleave", () => dropZone.classList.remove("drag"));
    dropZone.addEventListener("drop", (e) => {
      e.preventDefault();
      dropZone.classList.remove("drag");
      const f = e.dataTransfer?.files?.[0];
      if (f) setFile(f);
    });
  }

  function buildSummaryText(run){
    if (!run) return "—";
    const lines = [];

    lines.push("PROOFY – Notering");
    lines.push("");

    lines.push(`Kontrollvärde (Verifierings-ID): ${run.refId || "—"}`);
    if (run.fileName) lines.push(`Underlag/filnamn: ${run.fileName}`);

    lines.push("");
    lines.push(`Kontrolltid (Proofy): ${run.serverSe || "—"}`);
    lines.push(`Kontrolltid (Proofy, UTC): ${run.serverUtc || "—"}`);
    lines.push(`Kontrolltid (enhet): ${run.deviceSe || "—"}`);
    lines.push(`Kontrolltid (enhet, UTC): ${run.deviceUtc || "—"}`);
    lines.push("Obs: Proofy-tid kommer från serversvaret (serverTimeUnix). Ingen av tiderna utgör extern tidsstämpling. Enhetstid kan vara fel vid fel klocka.");

    if (run.httpDateRaw) {
      lines.push(`HTTP Date (transport, kompletterande): ${run.httpDateRaw}`);
    }

    lines.push("");
    lines.push(`Resultat (filversion): ${run.match ? "Oförändrat underlag (samma filversion)" : "Ändrat underlag (annan filversion)"}`);

    lines.push("");
    lines.push("Bevisstatus vid kontrolltillfället (registerstatus):");
    lines.push(`${run.statusText || "Kunde inte kontrolleras"}`);

    if (run.statusText === "Bekräftad") {
      if (run.confirmedSe) lines.push(`Tidpunkt (endast om bekräftad): ${run.confirmedSe}`);
      if (run.confirmedUtc) lines.push(`Tidpunkt (endast om bekräftad) – UTC: ${run.confirmedUtc}`);
    }

    if (run.registeredBlockNumber != null) {
      lines.push(`Registerblock (endast om bekräftad): ${run.registeredBlockNumber}`);
    }
    if (run.observedBlockNumber != null) {
      lines.push(`Observerat block (RPC, valfritt): ${run.observedBlockNumber}`);
    }

    if (run.tx) {
      lines.push("");
      lines.push(`Registreringsreferens (valfri): ${run.tx}`);
    }

    if (run.requestId) {
      lines.push("");
      lines.push(`Kontrollreferens (Proofy): ${run.requestId}`);
    }

    if (DEBUG) {
      lines.push("");
      lines.push(`Systemversion: ${PROOFY_VERIFY_BUILD}`);
    }

    lines.push("");
    lines.push("Avgränsning:");
    lines.push("Proofy uttalar sig inte om dokumentets innehåll, riktighet, giltighet eller äkthet.");
    lines.push("Kontrollen avser endast filversion och registerstatus vid angivet kontrolltillfälle.");

    return lines.join("\n");
  }

  if (copySummaryBtn) {
    copySummaryBtn.addEventListener("click", async () => {
      if (!lastRun) return;
      const txt = buildSummaryText(lastRun);
      await copyWithPill({ text: txt, pillEl: copySummaryPill, okText:"Notering kopierad ✅" });
    });
  }

  if (downloadReportBtn){
    downloadReportBtn.addEventListener("click", () => {
      if (!lastRun) return;
      const txt = buildSummaryText(lastRun);
      downloadTextFile("proofy-notering.txt", txt);
      showPill(copySummaryPill, "Sparad ✅");
    });
  }

  // ✅ Avbryt
  if (abortBtn){
    abortBtn.addEventListener("click", () => {
      if (!busy) return;
      try { if (fetchAbort) fetchAbort.abort(); } catch {}
      fetchAbort = null;

      opId++;
      busy = false;
      setStatus("Avbruten");
      setBusy(false);
      showPill(copySummaryPill, "Avbruten", 900);
    });
  }

  // ✅ Manuell “Kontrollera igen”
  verifyBtn.addEventListener("click", () => {
    if (busy) return;
    verifyNow({ auto:false });
  });

  async function verifyNow({ auto }){
    resetUI();

    const refId = hashInput.value.trim();
    if (!isValidId(refId)) {
      showAlert(
        "⚠️ Kontroll kan inte starta",
        "Verifierings-ID saknas eller verkar inte stämma. Kontrollera att du kopierat hela Verifierings-ID:t.",
        "err"
      );
      setStatus("Åtgärd krävs");
      hashInput.focus();
      return;
    }
    if (!currentFile) {
      showAlert(
        "⚠️ Välj ett underlag att kontrollera",
        "Välj underlaget du vill kontrollera. Underlaget lämnar inte din dator.",
        "err"
      );
      setStatus("Välj underlag");
      return;
    }

    const u = new URL(location.href);
    const tx = (u.searchParams.get("tx") || initialTx || "").trim();

    // ✅ Enhetstid (kompletterande)
    const checkedDeviceEpoch = Math.floor(Date.now() / 1000);

    // Vi sätter checked direkt (enhet) – uppdateras till Proofy-tid när den finns.
    setParamsInUrl({ hash: refId, checked: checkedDeviceEpoch, tx: tx || "" });

    const deviceSe = fmtSeEpoch(checkedDeviceEpoch);
    const deviceUtc = fmtUtcEpoch(checkedDeviceEpoch);

    if (outCheckedDeviceSe) outCheckedDeviceSe.textContent = deviceSe;
    if (outCheckedDeviceUtc) outCheckedDeviceUtc.textContent = deviceUtc;
    if (outCheckedServerSe) outCheckedServerSe.textContent = "—";
    if (outCheckedServerUtc) outCheckedServerUtc.textContent = "—";

    if (httpDateLine) httpDateLine.style.display = "none";
    if (httpDateOut) httpDateOut.textContent = "—";

    if (outRegisteredBlock) outRegisteredBlock.textContent = "—";
    if (outObservedBlock) outObservedBlock.textContent = "—";

    setStatus("Kontrollerar…");
    setBusy(true);

    const myOp = ++opId;

    // Abortcontroller för fetch
    try { if (fetchAbort) fetchAbort.abort(); } catch {}
    fetchAbort = new AbortController();

    try{
      const localId = await makeControlValue(currentFile);
      if (myOp !== opId) return;

      const match = (localId.toLowerCase() === refId.toLowerCase());

      const verifyRes = await fetchVerify(refId, tx || "", fetchAbort.signal);
      if (myOp !== opId) return;

      resultBox.style.display = "block";

      if (auditVerifyVersion && auditVerifyVersionValue){
        if (DEBUG) {
          auditVerifyVersionValue.textContent = PROOFY_VERIFY_BUILD;
          auditVerifyVersion.style.display = "block";
        } else {
          auditVerifyVersion.style.display = "none";
        }
      }

      // Normalisera (inkl serverTimeUnix + requestId)
      let norm = null;
      if (verifyRes.ok) norm = normalizeVerifyModel(verifyRes.data || {});
      const proofyEpoch = (norm && Number.isFinite(norm.serverTimeUnix) && norm.serverTimeUnix > 0) ? norm.serverTimeUnix : null;

      // HTTP Date (transport) – visas separat
      const httpDateRaw = String(verifyRes.dateHeader || "").trim();
      if (httpDateRaw && httpDateLine && httpDateOut) {
        httpDateOut.textContent = httpDateRaw;
        httpDateLine.style.display = "block";
      }

      const checkedEpochForLinks = proofyEpoch || checkedDeviceEpoch;

      const serverSe = proofyEpoch ? fmtSeEpoch(proofyEpoch) : "—";
      const serverUtc = proofyEpoch ? fmtUtcEpoch(proofyEpoch) : "—";

      if (outCheckedServerSe) outCheckedServerSe.textContent = serverSe;
      if (outCheckedServerUtc) outCheckedServerUtc.textContent = serverUtc;

      // ✅ Uppdatera URL så selflink/QR/cert får Proofy-checked när den finns
      if (proofyEpoch) {
        setParamsInUrl({ hash: refId, checked: proofyEpoch, tx: tx || "" });
      }

      if (reportMeta) {
        reportMeta.style.display = "block";
        reportMeta.textContent = `Rapport · kontrolltid: ${proofyEpoch ? serverSe : deviceSe}`;
      }

      setResultHeadline(match);
      setExplainTone(match);

      if (match) {
        outExplainTitle.textContent = "Filversionen stämmer med Verifierings-ID.";
        outExplainBody.textContent = "Kontrollen avser filversion och säger inget om dokumentets innehåll, giltighet eller äkthet.";
      } else {
        outExplainTitle.textContent = "Filversionen är ändrad jämfört med Verifierings-ID.";
        outExplainBody.textContent = "Det kan bero på att fel underlag valts eller att filen har skapats om/sparats på nytt (t.ex. ny export, omskanning eller omkomprimering).";
      }

      let statusText = "Kunde inte kontrolleras";
      let confirmedAtUnix = null;
      let requestId = "";

      // ✅ evidence (valfritt) från backend
      const evidence = (verifyRes && verifyRes.data && verifyRes.data.evidence) ? verifyRes.data.evidence : {};
      const observedBlockNumber = (evidence && evidence.observedBlockNumber != null) ? evidence.observedBlockNumber : null;
      const registeredBlockNumberRaw = (evidence && evidence.registeredBlockNumber != null) ? evidence.registeredBlockNumber : null;

      if (!verifyRes.ok || !norm) {
        statusText = "Kunde inte kontrolleras";
        outRegStatus.textContent = statusText;
        outRegSe.textContent = "—";
        outRegUtc.textContent = "—";
        outRegUtc.style.display = "none";

        if (outObservedBlock) outObservedBlock.textContent = observedBlockNumber != null ? String(observedBlockNumber) : "—";
        if (outRegisteredBlock) outRegisteredBlock.textContent = "—";
      } else {
        statusText = canonicalStatusFromCode(norm.statusCode);
        confirmedAtUnix = norm.confirmedAtUnix;
        requestId = norm.requestId || "";

        outRegStatus.textContent = statusText;

        if (statusText === "Bekräftad" && confirmedAtUnix) {
          outRegSe.textContent = (formatUnixSe(confirmedAtUnix) + " (Europe/Stockholm)");
          outRegUtc.textContent = fmtUtcEpoch(confirmedAtUnix);
          outRegUtc.style.display = "block";
        } else {
          outRegSe.textContent = "—";
          outRegUtc.textContent = "—";
          outRegUtc.style.display = "none";
        }

        // ✅ Block-evidence: visa alltid observerat block om finns, registerblock endast om bekräftad
        if (outObservedBlock) {
          outObservedBlock.textContent = (observedBlockNumber != null) ? String(observedBlockNumber) : "—";
        }
        if (outRegisteredBlock) {
          const show = (statusText === "Bekräftad") && (registeredBlockNumberRaw != null);
          outRegisteredBlock.textContent = show ? String(registeredBlockNumberRaw) : "—";
        }

        if (statusText === "Inskickad – ej bekräftad") {
          outExplainTitle.textContent = match
            ? "Filversionen stämmer – men bevisstatus är inskickad (ej bekräftad) vid kontrolltillfället."
            : "Filversionen avviker – och bevisstatus är inskickad (ej bekräftad) vid kontrolltillfället.";
          outExplainBody.textContent = "En inskickad notering innebär inte bekräftelse. Status blir “Bekräftad” först när bekräftelse kan konstateras i registret.";
        } else if (statusText === "Ej bekräftad") {
          outExplainTitle.textContent = match
            ? "Filversionen stämmer – men bevisstatus är ej bekräftad vid kontrolltillfället."
            : "Filversionen avviker – och bevisstatus är ej bekräftad vid kontrolltillfället.";
          outExplainBody.textContent = "Kontrollera att rätt Verifierings-ID används och försök igen vid behov.";
        } else if (statusText === "Kunde inte kontrolleras") {
          outExplainTitle.textContent = match
            ? "Filversionen stämmer – men bevisstatus kunde inte kontrolleras vid kontrolltillfället."
            : "Filversionen avviker – och bevisstatus kunde inte kontrolleras vid kontrolltillfället.";
          outExplainBody.textContent = "Detta kan vara ett tillfälligt tekniskt fel. Försök igen.";
        }
      }

      const confirmedSe = (statusText === "Bekräftad" && confirmedAtUnix) ? (formatUnixSe(confirmedAtUnix) + " (Europe/Stockholm)") : null;
      const confirmedUtc = (statusText === "Bekräftad" && confirmedAtUnix) ? fmtUtcEpoch(confirmedAtUnix) : null;

      if (openCertBtn) {
        openCertBtn.href = buildCertLink(refId, checkedEpochForLinks, tx || "");
        openCertBtn.target = "_blank";
        openCertBtn.rel = "noopener";
        openCertBtn.style.display = "inline-flex";
      }

      lastRun = {
        refId,
        match,
        fileName: currentFile?.name || "",
        statusText,
        confirmedSe,
        confirmedUtc,
        tx: tx || "",
        requestId: requestId || "",
        httpDateRaw: httpDateRaw || "",

        observedBlockNumber: (observedBlockNumber != null) ? String(observedBlockNumber) : null,
        registeredBlockNumber: (statusText === "Bekräftad" && registeredBlockNumberRaw != null) ? String(registeredBlockNumberRaw) : null,

        // tider till notering
        serverSe: proofyEpoch ? serverSe : "—",
        serverUtc: proofyEpoch ? serverUtc : "—",
        deviceSe,
        deviceUtc,
      };

      const summaryText = buildSummaryText(lastRun);
      if (summaryOut) summaryOut.textContent = summaryText;

      if (copySummaryBtn) copySummaryBtn.style.display = "inline-flex";
      if (downloadReportBtn) downloadReportBtn.style.display = "inline-flex";
      if (downloadHint) downloadHint.style.display = "block";
      if (jumpToNoteBtn) jumpToNoteBtn.style.display = "inline-flex";

      hideAlert();

      setStatus("Klar ✅");
      setBusy(false);

    } catch (e){
      if (myOp !== opId) return;
      errorBox.style.display = "block";
      errorMsg.textContent = e?.message || "Tekniskt fel.";
      setStatus("Åtgärd krävs");
      setBusy(false);
    } finally {
      fetchAbort = null;
    }
  }

  // init
  resetUI();
  setFile(null);

  if (auditVerifyVersion && auditVerifyVersionValue) {
    if (DEBUG) {
      auditVerifyVersionValue.textContent = PROOFY_VERIFY_BUILD;
    } else {
      auditVerifyVersion.style.display = "none";
    }
  }

  updateSelfLinkUI();
  updateValidationUI();

  /*
    ✅ Overlay-safe:
    Mät “fixed” widget nere i hörn (t.ex. Fråga oss / chat widget) och reservera utrymme i main.
    Robust: funkar även om widget renderas sent (observer + light polling).
  */
  (function overlaySafe(){
    const root = document.documentElement;

    const candidates = () => {
      const els = [];
      const byId1 = document.getElementById("chatWidget");
      const byId2 = document.getElementById("chat-widget");
      if (byId1) els.push(byId1);
      if (byId2) els.push(byId2);

      const maybe = Array.from(document.querySelectorAll("button, a, div, iframe"))
        .filter(el => {
          if (!el || !el.getBoundingClientRect) return false;
          const cs = getComputedStyle(el);
          if (cs.position !== "fixed") return false;
          const r = el.getBoundingClientRect();
          if (r.width < 40 || r.height < 40) return false;

          const nearBottom = r.bottom > (window.innerHeight - 40);
          const nearRight = r.right > (window.innerWidth - 120);
          const nearLeft = r.left < 120;
          return nearBottom && (nearRight || nearLeft);
        });

      for (const el of maybe) els.push(el);
      return Array.from(new Set(els));
    };

    const compute = () => {
      const list = candidates();
      let extra = 0;

      for (const el of list){
        try{
          const r = el.getBoundingClientRect();
          if (r.height > extra) extra = r.height;
        } catch {}
      }

      const px = extra > 0 ? Math.ceil(extra + 18) : 0;
      root.style.setProperty("--proofy-fab-space", px + "px");
    };

    compute();
    window.addEventListener("resize", () => compute(), { passive:true });

    const obs = new MutationObserver(() => compute());
    obs.observe(document.body, { childList:true, subtree:true, attributes:true });

    let n = 0;
    const t = setInterval(() => {
      compute();
      n++;
      if (n > 8) clearInterval(t);
    }, 180);
  })();

})();
</script>

<script src="/assets/header-toggle.js?v=2026-01-03a" defer></script>
<script src="/chat-widget.js?v=2026-01-03a" defer></script>
</body>
</html>
