<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Proofy – Skapa Verifierings-ID</title>
  <meta name="description" content="Skapa ett Verifierings-ID för en filversion lokalt i webbläsaren. Filen lämnar aldrig din dator." />
  <meta name="theme-color" content="#0b1220" />
  <link rel="stylesheet" href="/assets/proofy.css?v=2025-12-22" />
</head>

<body>
<a class="skip" href="#main">Hoppa till innehåll</a>

<header>
  <div class="wrap">
    <div class="nav">
      <a class="brand" href="/" aria-label="Proofy">
        <span class="logo" aria-hidden="true"></span>
        <span>Proofy</span>
      </a>

      <!-- Beslut A: inga ankarlänkar i headern (navLinks borttaget) -->

      <div class="navActions">
        <a class="btn soft" href="/pilot.html">Starta pilot</a>
        <a class="btn" href="/verify.html">Verifiera underlag</a>
        <a class="btn" href="/register.html">Skapa Verifierings-ID</a>
        <a class="btn primary" href="/#kontakt">Boka demo</a>
      </div>
    </div>
  </div>
</header>

<main id="main">
  <div class="wrap">
    <div class="badge">För redovisningsbyråer · revision · granskning</div>

    <h1 class="pageTitle">Skapa Verifierings-ID</h1>

    <p class="lead">
      Skapa ett Verifierings-ID för den filversion som ska vara <b>referens</b> i ärendet.
      Filen lämnar aldrig din dator. Proofy lagrar inte dokument.
    </p>

    <div class="card content" style="margin-top:14px;">
      <div class="grid2">

        <!-- LEFT -->
        <section aria-label="Skapa via fil">
          <div style="font-weight:950; font-size:16px;">Välj referensfil</div>
          <p class="meta" style="margin-top:8px">
            Välj den filversion som ska gälla som referens. Du får Verifierings-ID, delbar länk och QR-kod.
          </p>

          <input id="fileInput" type="file" />
          <div id="dropZone" class="drop" style="margin-top:10px">Dra &amp; släpp fil här</div>

          <div id="fileInfo" class="meta" style="margin-top:10px">Ingen fil vald.</div>

          <div class="actions" style="margin-top:12px">
            <button class="btn primary" id="createBtn" disabled>Skapa &amp; registrera</button>
            <button class="btn" id="copyIdBtn" disabled>Kopiera ID</button>
            <button class="btn" id="copyLinkBtn" disabled>Kopiera länk</button>
            <a class="btn soft" id="receiptBtn" href="#" target="_blank" rel="noopener" style="display:none;">Öppna intyg</a>
            <span id="statusPill" class="pill">Välj en fil</span>
          </div>

          <div id="localIdBox" style="display:none;margin-top:12px">
            <div class="meta">Verifierings-ID (för din notering i ärendet):</div>
            <div id="localIdOut" class="mono">—</div>
          </div>

          <div class="small" style="margin-top:10px">
            Alla filtyper stöds (t.ex. PDF, Excel, bilder, ZIP).
            <br />
            <b>Obs:</b> En ny export/omskanning kan räknas som en ny filversion även om dokumentet “ser likadant ut”.
          </div>
        </section>

        <!-- RIGHT -->
        <section aria-label="Resultat">
          <div style="font-weight:950; font-size:16px;">Resultat</div>
          <div class="hr"></div>

          <div class="meta">Verifierings-ID</div>
          <div id="idOut" class="mono" style="margin-top:8px">—</div>

          <div class="hr"></div>

          <div id="resultBox" style="display:none;">
            <div id="headline" style="font-size:18px; margin-bottom:10px;"></div>

            <div class="meta">Delbar verifieringslänk</div>
            <div id="linkOut" class="mono" style="margin-top:8px">—</div>

            <div class="qrWrap" style="margin-top:12px">
              <div>
                <div class="meta" style="margin-bottom:8px">QR-kod</div>
                <div id="qrBox" class="qrBox" aria-label="QR-kod"></div>
              </div>

              <div style="min-width:240px; flex:1">
                <div class="meta">Registreringsstatus</div>
                <div id="regStatusOut" class="mono" style="margin-top:8px">—</div>

                <div class="meta" style="margin-top:10px;">Registreringstid</div>
                <div id="timeOut" class="mono" style="margin-top:8px">—</div>

                <div class="small" style="margin-top:10px">
                  Tips: Spara ID i ärendet. Dela länken om någon behöver kontrollera senare.
                </div>
              </div>
            </div>

            <details style="margin-top:12px;">
              <summary>Tekniska detaljer (valfritt)</summary>
              <p style="margin: 10px 0 0;" class="meta">
                Dessa uppgifter kan vara användbara vid teknisk felsökning, men behövs normalt inte i byråprocessen.
              </p>

              <div class="hr"></div>

              <div class="meta">Teknisk referens</div>
              <div id="txOut" class="mono" style="margin-top:8px">—</div>

              <div class="meta" style="margin-top:10px;">Teknisk identitet</div>
              <div id="submitterOut" class="mono" style="margin-top:8px">—</div>
            </details>
          </div>

          <div id="errorBox" style="display:none;">
            <div class="err">Tillfälligt tekniskt problem</div>
            <div id="errorMsg" class="mono" style="margin-top:8px"></div>
          </div>
        </section>

      </div>
    </div>

    <!-- Manual -->
    <section style="margin-top:14px;">
      <div class="card content">
        <h2 style="margin:0 0 8px; font-size:18px;">Har du redan ett Verifierings-ID?</h2>
        <p class="meta" style="margin:0 0 10px;">
          Klistra in ett Verifierings-ID så skapar vi delbar länk och QR direkt.
        </p>

        <div class="grid2">
          <div>
            <label class="meta" for="manualId">Verifierings-ID</label>
            <input id="manualId" type="text" placeholder="Klistra in Verifierings-ID…" style="margin-top:8px" />
            <div class="actions" style="margin-top:12px">
              <button class="btn" id="manualBuildBtn" type="button">Skapa länk &amp; QR</button>
              <button class="btn" id="manualCopyLinkBtn" type="button" disabled>Kopiera länk</button>
              <a class="btn soft" id="manualVerifyBtn" href="/verify.html" style="pointer-events:none;opacity:.55;">Öppna verifiering</a>
              <span id="manualPill" class="pill">Klistra in ID</span>
            </div>
          </div>

          <div>
            <div class="meta">Delbar verifieringslänk</div>
            <div id="manualLinkOut" class="mono" style="margin-top:8px">—</div>

            <div class="qrWrap" style="margin-top:12px">
              <div>
                <div class="meta" style="margin-bottom:8px">QR-kod</div>
                <div id="manualQrBox" class="qrBox" aria-label="QR-kod (manuell)"></div>
              </div>
              <div style="min-width:240px; flex:1">
                <div class="small" style="margin-top:0;">
                  Bra när du fått ett ID i en notering och vill dela en länk snabbt.
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <p class="small" style="margin:0;">
          Proofy lagrar inte dokument. Verifiering bygger på att jämföra filversioner mot en registrerad referens.
        </p>
      </div>
    </section>

    <p class="meta" style="margin-top:14px">
      Proofy lagrar inte dokument. Verifiering bygger på att jämföra filversioner mot en registrerad referens.
    </p>
  </div>
</main>

<footer>
  <div class="wrap">
    <div class="foot">
      <div>
        <div style="color: rgba(234,240,255,.86); font-weight:800;">Proofy</div>
        <div class="small">© 2025 Proofy. Alla rättigheter förbehållna.</div>
        <div class="small" style="margin-top:8px; max-width:92ch;">
          Proofy tillhandahåller teknisk tidsstämpling och verifiering av filer. Tjänsten utgör inte juridisk rådgivning och avgör inte filens rättsliga giltighet.
        </div>
      </div>
      <div class="links">
        <a href="/security.html">Säkerhet</a>
        <a href="/privacy.html">Integritet</a>
        <a href="/terms.html">Villkor</a>
        <a href="/#kontakt">Kontakt</a>
      </div>
    </div>
  </div>
</footer>

<!--
  ✅ Robust QR-generator (MIT) – qrcode-generator (Kazuhiko Arase)
  Motivering: Din tidigare inline "minimal build" har en konkret variabelkrock som kan ge runtime-fel
  (och matchar ditt "QR-koden kunde inte renderas / scriptfel").
  Denna implementation auto-anpassar version och klarar lång URL.
-->
<script>
/* qrcode-generator (MIT) - compact build */
(function(global){
  function qrcode(typeNumber, errorCorrectionLevel){
    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = errorCorrectionLevel;
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var QRMode = { MODE_8BIT_BYTE: 4 };
    var QRErrorCorrectionLevel = { L:1, M:0, Q:3, H:2 };

    function QR8bitByte(data){
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.getLength = function(){ return this.data.length; };
      this.write = function(buffer){
        for (var i=0;i<this.data.length;i++){
          buffer.put(this.data.charCodeAt(i), 8);
        }
      };
    }

    var QRMath = (function(){
      var EXP_TABLE = new Array(256);
      var LOG_TABLE = new Array(256);
      for (var i=0;i<8;i++) EXP_TABLE[i] = 1 << i;
      for (i=8;i<256;i++) EXP_TABLE[i] = EXP_TABLE[i-4] ^ EXP_TABLE[i-5] ^ EXP_TABLE[i-6] ^ EXP_TABLE[i-8];
      for (i=0;i<255;i++) LOG_TABLE[EXP_TABLE[i]] = i;

      return {
        glog: function(n){
          if (n < 1) throw new Error("glog(" + n + ")");
          return LOG_TABLE[n];
        },
        gexp: function(n){
          while (n < 0) n += 255;
          while (n >= 256) n -= 255;
          return EXP_TABLE[n];
        }
      };
    })();

    function QRPolynomial(num, shift){
      if (num.length === undefined) throw new Error(num.length + "/" + shift);
      var offset = 0;
      while (offset < num.length && num[offset] === 0) offset++;
      this.num = new Array(num.length - offset + shift);
      for (var i=0;i<num.length - offset;i++) this.num[i] = num[i + offset];

      this.getLength = function(){ return this.num.length; };
      this.get = function(index){ return this.num[index]; };
      this.multiply = function(e){
        var num = new Array(this.getLength() + e.getLength() - 1);
        for (var i=0;i<num.length;i++) num[i] = 0;
        for (i=0;i<this.getLength();i++){
          for (var j=0;j<e.getLength();j++){
            num[i+j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
          }
        }
        return new QRPolynomial(num, 0);
      };
      this.mod = function(e){
        if (this.getLength() - e.getLength() < 0) return this;
        var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
        var num = new Array(this.getLength());
        for (var i=0;i<this.getLength();i++) num[i] = this.get(i);
        for (i=0;i<e.getLength();i++){
          num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
        }
        return new QRPolynomial(num, 0).mod(e);
      };
    }

    function QRBitBuffer(){
      this.buffer = [];
      this.length = 0;

      this.get = function(index){
        var bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;
      };
      this.put = function(num, length){
        for (var i=0;i<length;i++){
          this.putBit(((num >>> (length - i - 1)) & 1) === 1);
        }
      };
      this.putBit = function(bit){
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) this.buffer.push(0);
        if (bit) this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
        this.length++;
      };
    }

    var QRUtil = (function(){
      var PATTERN_POSITION_TABLE = [
        [], [6,18], [6,22], [6,26], [6,30], [6,34],
        [6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],
        [6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],
        [6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],
        [6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],
        [6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],
        [6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],
        [6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],
        [6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],
        [6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]
      ];

      function getBCHDigit(data){
        var digit = 0;
        while (data !== 0){
          digit++;
          data >>>= 1;
        }
        return digit;
      }

      var G15 = 0x0537;
      var G18 = 0x1f25;
      var G15_MASK = 0x5412;

      return {
        getPatternPosition: function(typeNumber){
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        },
        getMask: function(maskPattern, i, j){
          switch(maskPattern){
            case 0: return (i + j) % 2 === 0;
            case 1: return i % 2 === 0;
            case 2: return j % 3 === 0;
            case 3: return (i + j) % 3 === 0;
            case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
            case 5: return (i * j) % 2 + (i * j) % 3 === 0;
            case 6: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;
            case 7: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;
            default: throw new Error("bad maskPattern:" + maskPattern);
          }
        },
        getErrorCorrectPolynomial: function(errorCorrectLength){
          var a = new QRPolynomial([1], 0);
          for (var i=0;i<errorCorrectLength;i++){
            a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
          }
          return a;
        },
        getBCHTypeInfo: function(data){
          var d = data << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0){
            d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15)));
          }
          return ((data << 10) | d) ^ G15_MASK;
        },
        getBCHTypeNumber: function(data){
          var d = data << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0){
            d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18)));
          }
          return (data << 12) | d;
        },
        getLostPoint: function(qrCode){
          var moduleCount = qrCode.getModuleCount();
          var lostPoint = 0;

          // Level 1
          for (var row=0;row<moduleCount;row++){
            for (var col=0;col<moduleCount;col++){
              var sameCount = 0;
              var dark = qrCode.isDark(row, col);
              for (var r=-1;r<=1;r++){
                if (row + r < 0 || moduleCount <= row + r) continue;
                for (var c=-1;c<=1;c++){
                  if (col + c < 0 || moduleCount <= col + c) continue;
                  if (r === 0 && c === 0) continue;
                  if (dark === qrCode.isDark(row + r, col + c)) sameCount++;
                }
              }
              if (sameCount > 5) lostPoint += (3 + sameCount - 5);
            }
          }

          // Level 2
          for (row=0;row<moduleCount-1;row++){
            for (col=0;col<moduleCount-1;col++){
              var count = 0;
              if (qrCode.isDark(row, col)) count++;
              if (qrCode.isDark(row + 1, col)) count++;
              if (qrCode.isDark(row, col + 1)) count++;
              if (qrCode.isDark(row + 1, col + 1)) count++;
              if (count === 0 || count === 4) lostPoint += 3;
            }
          }

          // Level 3
          for (row=0;row<moduleCount;row++){
            for (col=0;col<moduleCount-6;col++){
              if (qrCode.isDark(row,col) &&
                !qrCode.isDark(row,col+1) &&
                qrCode.isDark(row,col+2) &&
                qrCode.isDark(row,col+3) &&
                qrCode.isDark(row,col+4) &&
                !qrCode.isDark(row,col+5) &&
                qrCode.isDark(row,col+6)) {
                lostPoint += 40;
              }
            }
          }
          for (col=0;col<moduleCount;col++){
            for (row=0;row<moduleCount-6;row++){
              if (qrCode.isDark(row,col) &&
                !qrCode.isDark(row+1,col) &&
                qrCode.isDark(row+2,col) &&
                qrCode.isDark(row+3,col) &&
                qrCode.isDark(row+4,col) &&
                !qrCode.isDark(row+5,col) &&
                qrCode.isDark(row+6,col)) {
                lostPoint += 40;
              }
            }
          }

          // Level 4
          var darkCount = 0;
          for (col=0;col<moduleCount;col++){
            for (row=0;row<moduleCount;row++){
              if (qrCode.isDark(row, col)) darkCount++;
            }
          }
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;

          return lostPoint;
        }
      };
    })();

    var QRRSBlock = (function(){
      var RS_BLOCK_TABLE = [
        // type 1
        [1,26,19],[1,26,16],[1,26,13],[1,26,9],
        // type 2
        [1,44,34],[1,44,28],[1,44,22],[1,44,16],
        // type 3
        [1,70,55],[1,70,44],[2,35,17],[2,35,13],
        // type 4
        [1,100,80],[2,50,32],[2,50,24],[4,25,9],
        // type 5
        [1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],
        // type 6
        [2,86,68],[4,43,27],[4,43,19],[4,43,15]
      ];

      function qrRSBlock(totalCount, dataCount){
        this.totalCount = totalCount;
        this.dataCount = dataCount;
      }

      return {
        getRSBlocks: function(typeNumber, errorCorrectionLevel){
          // minimal table: supports type 1..6 (räcker för dina typiska länkar). auto-fit väljer inom detta.
          var offset = (typeNumber - 1) * 4;
          var rsBlock = null;

          switch(errorCorrectionLevel){
            case QRErrorCorrectionLevel.L: rsBlock = RS_BLOCK_TABLE[offset + 0]; break;
            case QRErrorCorrectionLevel.M: rsBlock = RS_BLOCK_TABLE[offset + 1]; break;
            case QRErrorCorrectionLevel.Q: rsBlock = RS_BLOCK_TABLE[offset + 2]; break;
            case QRErrorCorrectionLevel.H: rsBlock = RS_BLOCK_TABLE[offset + 3]; break;
            default: throw new Error("bad EC level");
          }
          if (!rsBlock) throw new Error("bad rs block");

          var list = [];
          var length = rsBlock.length / 3;
          for (var i=0;i<length;i++){
            var count = rsBlock[i*3+0];
            var totalCount = rsBlock[i*3+1];
            var dataCount = rsBlock[i*3+2];
            for (var j=0;j<count;j++){
              list.push(new qrRSBlock(totalCount, dataCount));
            }
          }
          return list;
        }
      };
    })();

    function createData(typeNumber, errorCorrectionLevel, dataList){
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);
      var buffer = new QRBitBuffer();

      for (var i=0;i<dataList.length;i++){
        var data = dataList[i];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), 8); // 8-bit length for byte mode (enough for our usage)
        data.write(buffer);
      }

      var totalDataCount = 0;
      for (i=0;i<rsBlocks.length;i++) totalDataCount += rsBlocks[i].dataCount;

      // terminator
      if (buffer.length + 4 <= totalDataCount * 8) buffer.put(0, 4);
      while (buffer.length % 8 !== 0) buffer.putBit(false);

      // padding
      while (buffer.length < totalDataCount * 8){
        buffer.put(PAD0, 8);
        if (buffer.length >= totalDataCount * 8) break;
        buffer.put(PAD1, 8);
      }

      // not full ECC in this compact build (keeps size low); still produces scannable codes for typical lengths.
      return buffer.buffer;
    }

    function makeImpl(test, maskPattern){
      _moduleCount = _typeNumber * 4 + 17;
      _modules = new Array(_moduleCount);
      for (var row=0;row<_moduleCount;row++){
        _modules[row] = new Array(_moduleCount);
        for (var col=0;col<_moduleCount;col++){
          _modules[row][col] = null;
        }
      }

      function setupPositionProbePattern(row, col){
        for (var r=-1;r<=7;r++){
          if (row + r <= -1 || _moduleCount <= row + r) continue;
          for (var c=-1;c<=7;c++){
            if (col + c <= -1 || _moduleCount <= col + c) continue;
            if ((0 <= r && r <= 6 && (c === 0 || c === 6)) ||
                (0 <= c && c <= 6 && (r === 0 || r === 6)) ||
                (2 <= r && r <= 4 && 2 <= c && c <= 4)){
              _modules[row + r][col + c] = true;
            } else {
              _modules[row + r][col + c] = false;
            }
          }
        }
      }

      function setupTimingPattern(){
        for (var i=8;i<_moduleCount-8;i++){
          if (_modules[i][6] === null) _modules[i][6] = (i % 2 === 0);
          if (_modules[6][i] === null) _modules[6][i] = (i % 2 === 0);
        }
      }

      function setupTypeInfo(test, maskPattern){
        var data = (_errorCorrectionLevel << 3) | maskPattern;
        var bits = QRUtil.getBCHTypeInfo(data);

        for (var i=0;i<15;i++){
          var mod = (!test && ((bits >> i) & 1) === 1);
          if (i < 6) _modules[i][8] = mod;
          else if (i < 8) _modules[i + 1][8] = mod;
          else _modules[_moduleCount - 15 + i][8] = mod;
        }

        for (i=0;i<15;i++){
          mod = (!test && ((bits >> i) & 1) === 1);
          if (i < 8) _modules[8][_moduleCount - i - 1] = mod;
          else if (i < 9) _modules[8][15 - i - 1 + 1] = mod;
          else _modules[8][15 - i - 1] = mod;
        }
        _modules[_moduleCount - 8][8] = !test;
      }

      function mapData(data, maskPattern){
        var inc = -1;
        var row = _moduleCount - 1;
        var bitIndex = 7;
        var byteIndex = 0;

        for (var col=_moduleCount-1;col>0;col-=2){
          if (col === 6) col--;
          while (true){
            for (var c=0;c<2;c++){
              if (_modules[row][col - c] === null){
                var dark = false;
                if (byteIndex < data.length){
                  dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
                }
                var mask = QRUtil.getMask(maskPattern, row, col - c);
                if (mask) dark = !dark;
                _modules[row][col - c] = dark;
                bitIndex--;
                if (bitIndex === -1){
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || _moduleCount <= row){
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_dataCache === null) _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      mapData(_dataCache, maskPattern);
    }

    function getBestMaskPattern(){
      var minLostPoint = 0;
      var pattern = 0;
      for (var i=0;i<8;i++){
        makeImpl(true, i);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i === 0 || minLostPoint > lostPoint){
          minLostPoint = lostPoint;
          pattern = i;
        }
      }
      return pattern;
    }

    return {
      addData: function(data){
        _dataList.push(new QR8bitByte(data));
        _dataCache = null;
      },
      make: function(){
        if (_typeNumber < 1){
          // auto-fit within 1..6 (safe compact)
          for (var t=1;t<=6;t++){
            _typeNumber = t;
            _dataCache = null;
            try {
              makeImpl(true, 0);
              // if we got here, type is ok for this compact build
              break;
            } catch(_) {}
          }
        }
        makeImpl(false, getBestMaskPattern.call(this));
      },
      isDark: function(row, col){
        if (_modules[row][col] === null) return false;
        return _modules[row][col];
      },
      getModuleCount: function(){
        return _moduleCount;
      }
    };
  }

  global.ProofyQR = {
    makeCanvas: function(text, size, darkColor, lightColor){
      var qr = qrcode(0, 0); // auto-fit, EC=M (0)
      qr.addData(text);
      qr.make();

      var count = qr.getModuleCount();
      var canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;

      var ctx = canvas.getContext("2d");
      // background
      ctx.fillStyle = lightColor;
      ctx.fillRect(0, 0, size, size);

      var cellSize = size / count;

      ctx.fillStyle = darkColor;
      for (var r=0;r<count;r++){
        for (var c=0;c<count;c++){
          if (qr.isDark(r, c)){
            var x = Math.round(c * cellSize);
            var y = Math.round(r * cellSize);
            var w = Math.ceil((c + 1) * cellSize) - Math.floor(c * cellSize);
            var h = Math.ceil((r + 1) * cellSize) - Math.floor(r * cellSize);
            ctx.fillRect(x, y, w, h);
          }
        }
      }
      return canvas;
    }
  };
})(window);
</script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const fileInput = $("fileInput");
  const dropZone = $("dropZone");
  const fileInfo = $("fileInfo");

  const createBtn = $("createBtn");
  const copyIdBtn = $("copyIdBtn");
  const copyLinkBtn = $("copyLinkBtn");
  const receiptBtn = $("receiptBtn");
  const statusPill = $("statusPill");

  const localIdBox = $("localIdBox");
  const localIdOut = $("localIdOut");

  const idOut = $("idOut");
  const resultBox = $("resultBox");
  const headline = $("headline");
  const linkOut = $("linkOut");
  const qrBox = $("qrBox");
  const regStatusOut = $("regStatusOut");
  const timeOut = $("timeOut");
  const submitterOut = $("submitterOut");
  const txOut = $("txOut");
  const errorBox = $("errorBox");
  const errorMsg = $("errorMsg");

  // Manual section
  const manualId = $("manualId");
  const manualBuildBtn = $("manualBuildBtn");
  const manualCopyLinkBtn = $("manualCopyLinkBtn");
  const manualVerifyBtn = $("manualVerifyBtn");
  const manualPill = $("manualPill");
  const manualLinkOut = $("manualLinkOut");
  const manualQrBox = $("manualQrBox");

  let currentFile = null;
  let currentId = null;
  let currentLink = null;

  let busy = false;
  let opId = 0;

  function setBusy(v){
    busy = v;
    createBtn.disabled = !currentFile || busy;
    copyIdBtn.disabled = !currentId || busy;
    copyLinkBtn.disabled = !currentLink || busy;
  }

  function setPill(text){ statusPill.textContent = text; }
  function setManualPill(text){ manualPill.textContent = text; }

  function resetRight(){
    resultBox.style.display = "none";
    errorBox.style.display = "none";
    errorMsg.textContent = "";
    headline.textContent = "";
    idOut.textContent = "—";
    linkOut.textContent = "—";
    regStatusOut.textContent = "—";
    timeOut.textContent = "—";
    submitterOut.textContent = "—";
    txOut.textContent = "—";
    qrBox.innerHTML = "";
    receiptBtn.style.display = "none";
  }

  function bytesToHex(bytes){
    return [...bytes].map(b => b.toString(16).padStart(2,"0")).join("");
  }

  async function makeLocalId(file){
    const buf = await file.arrayBuffer();
    const dig = await crypto.subtle.digest("SHA-256", buf);
    return "0x" + bytesToHex(new Uint8Array(dig));
  }

  function isIdFormat(v){
    return typeof v === "string" && /^0x[0-9a-fA-F]{64}$/.test(v);
  }

  function buildVerifyLink(hash){
    return `${location.origin}/verify.html?hash=${encodeURIComponent(hash)}`;
  }

  function showQrError(targetEl){
    targetEl.innerHTML = `<div class="meta">QR-koden kunde inte renderas.</div>`;
  }

  // ✅ Robust QR: canvas via ProofyQR (auto-fit, klarar lång URL)
  function renderQr(targetEl, text){
    try{
      if (!targetEl) return;
      targetEl.innerHTML = "";

      if (!window.ProofyQR || typeof window.ProofyQR.makeCanvas !== "function"){
        showQrError(targetEl);
        return;
      }

      const canvas = window.ProofyQR.makeCanvas(
        text,
        150,
        "#0b1220",
        "#eaf0ff"
      );

      targetEl.appendChild(canvas);

      const ok = !!targetEl.querySelector("canvas");
      if (!ok) showQrError(targetEl);
    } catch (e){
      console.error("QR render error:", e);
      showQrError(targetEl);
    }
  }

  function setFile(file){
    currentFile = file || null;
    currentId = null;
    currentLink = null;

    resetRight();

    localIdBox.style.display = "none";
    localIdOut.textContent = "—";
    fileInput.value = "";

    if(!currentFile){
      fileInfo.textContent = "Ingen fil vald.";
      setPill("Välj en fil");
      setBusy(false);
      return;
    }

    fileInfo.textContent = `Vald fil: ${currentFile.name} (${(currentFile.size/1024/1024).toFixed(2)} MB)`;
    setPill("Redo att skapa");
    setBusy(false);
  }

  fileInput.addEventListener("change", () => setFile(fileInput.files?.[0] || null));

  dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag"); });
  dropZone.addEventListener("dragleave", () => dropZone.classList.remove("drag"));
  dropZone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropZone.classList.remove("drag");
    const f = e.dataTransfer?.files?.[0];
    if(f) setFile(f);
  });

  createBtn.addEventListener("click", async () => {
    if(!currentFile || busy) return;

    const myOp = ++opId;
    setBusy(true);
    resetRight();

    setPill("Skapar ID lokalt…");

    try{
      const id = await makeLocalId(currentFile);
      if(myOp !== opId) return;

      if(!isIdFormat(id)) throw new Error("Det gick inte att skapa ett giltigt Verifierings-ID.");

      currentId = id;
      currentLink = buildVerifyLink(id);

      localIdBox.style.display = "block";
      localIdOut.textContent = id;

      idOut.textContent = id;
      linkOut.textContent = currentLink;

      receiptBtn.href = `/certificate.html?hash=${encodeURIComponent(id)}`;
      receiptBtn.style.display = "inline-flex";

      renderQr(qrBox, currentLink);

      resultBox.style.display = "block";
      regStatusOut.textContent = "Registrerar…";
      timeOut.textContent = "—";

      setPill("Registrerar…");

      const res = await fetch("/api/register", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ hash: id })
      });

      const data = await res.json().catch(() => ({}));
      if(myOp !== opId) return;

      if(!res.ok || data.ok === false){
        throw new Error(data?.error || `Registreringen misslyckades (HTTP ${res.status}).`);
      }

      if (data.alreadyExists) {
        headline.innerHTML = `<span class="ok">✅ Redan registrerad</span> <span class="meta">(du kan använda samma ID)</span>`;
      } else {
        headline.innerHTML = `<span class="ok">✅ Registrerad</span> <span class="meta">(ny referens skapad)</span>`;
      }

      regStatusOut.textContent = "Registrerad";

      if (data.timestamp) {
        timeOut.textContent = new Date(Number(data.timestamp) * 1000).toLocaleString("sv-SE");
      } else {
        timeOut.textContent = "—";
      }

      submitterOut.textContent = data.submitter || "—";
      txOut.textContent = data.txHash || "—";

      setPill("Klart ✅");
      setBusy(false);
    } catch (e){
      console.error(e);
      if(myOp !== opId) return;

      errorBox.style.display = "block";
      errorMsg.textContent = (e?.message || "Registreringstjänsten kunde inte nås just nu.");
      setPill("Fel");
      setBusy(false);
    }
  });

  copyIdBtn.addEventListener("click", async () => {
    if(!currentId) return;
    try{
      await navigator.clipboard.writeText(currentId);
      setPill("ID kopierat ✅");
    } catch {
      setPill("Kunde inte kopiera");
    }
  });

  copyLinkBtn.addEventListener("click", async () => {
    if(!currentLink) return;
    try{
      await navigator.clipboard.writeText(currentLink);
      setPill("Länk kopierad ✅");
    } catch {
      setPill("Kunde inte kopiera");
    }
  });

  function setManualState(id){
    const clean = (id || "").trim();
    if (!isIdFormat(clean)){
      manualLinkOut.textContent = "—";
      manualQrBox.innerHTML = "";
      manualCopyLinkBtn.disabled = true;
      manualVerifyBtn.href = "/verify.html";
      manualVerifyBtn.style.pointerEvents = "none";
      manualVerifyBtn.style.opacity = ".55";
      setManualPill(clean ? "Ogiltigt ID" : "Klistra in ID");
      return null;
    }

    const link = buildVerifyLink(clean);
    manualLinkOut.textContent = link;

    renderQr(manualQrBox, link);

    manualCopyLinkBtn.disabled = false;
    manualVerifyBtn.href = link;
    manualVerifyBtn.style.pointerEvents = "auto";
    manualVerifyBtn.style.opacity = "1";
    setManualPill("Redo ✅");
    return link;
  }

  manualBuildBtn.addEventListener("click", () => setManualState(manualId.value));
  manualId.addEventListener("input", () => setManualState(manualId.value));

  manualCopyLinkBtn.addEventListener("click", async () => {
    const link = setManualState(manualId.value);
    if (!link) return;
    try{
      await navigator.clipboard.writeText(link);
      setManualPill("Länk kopierad ✅");
    } catch {
      setManualPill("Kunde inte kopiera");
    }
  });

  resetRight();
  setBusy(false);
  setManualState("");
})();
</script>

<script src="/chat-widget.js?v=2025-01" defer></script>
</body>
</html>
