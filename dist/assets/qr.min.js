/*! qrcode.js (MIT) - fixed build for Proofy: restores RS/EC + fixes auto typeNumber + adds margin */
(function(){
function QR8bitByte(data){this.mode=QRMode.MODE_8BIT_BYTE;this.data=data;}
function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
function QRBitBuffer(){this.buffer=[];this.length=0;}
function QRCodeModel(typeNumber,errorCorrectLevel){
  this.typeNumber=typeNumber;
  this.errorCorrectLevel=errorCorrectLevel;
  this.modules=null;
  this.moduleCount=0;
  this.dataCache=null;
  this.dataList=[];
}

function QRMath(){
  this.expTable=new Array(256);
  this.logTable=new Array(256);
  for(var i=0;i<8;i++) this.expTable[i]=1<<i;
  for(i=8;i<256;i++) this.expTable[i]=this.expTable[i-4]^this.expTable[i-5]^this.expTable[i-6]^this.expTable[i-8];
  for(i=0;i<255;i++) this.logTable[this.expTable[i]]=i;
}
var QRMode={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8};
var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};

var QRUtil={
PATTERN_POSITION_TABLE:[
[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]
],
G15:1335,G18:7973,G15_MASK:21522,
getBCHTypeInfo:function(data){
  var d=data<<10;
  while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){
    d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));
  }
  return ((data<<10)|d)^QRUtil.G15_MASK;
},
getBCHTypeNumber:function(data){
  var d=data<<12;
  while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){
    d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));
  }
  return (data<<12)|d;
},
getBCHDigit:function(data){
  var digit=0;
  while(data!==0){digit++;data>>>=1;}
  return digit;
},
getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},
getMask:function(maskPattern,i,j){
  switch(maskPattern){
    case 0: return (i+j)%2===0;
    case 1: return i%2===0;
    case 2: return j%3===0;
    case 3: return (i+j)%3===0;
    case 4: return (Math.floor(i/2)+Math.floor(j/3))%2===0;
    case 5: return (i*j)%2+(i*j)%3===0;
    case 6: return ((i*j)%2+(i*j)%3)%2===0;
    case 7: return ((i*j)%3+(i+j)%2)%2===0;
    default: throw new Error("bad maskPattern:"+maskPattern);
  }
},
getErrorCorrectPolynomial:function(errorCorrectLength){
  var a=new QRPolynomial([1],0);
  for(var i=0;i<errorCorrectLength;i++){
    a=a.multiply(new QRPolynomial([1,QRMathImpl.exp(i)],0));
  }
  return a;
},
getLengthInBits:function(mode,type){
  if(1<=type && type<10){
    switch(mode){
      case QRMode.MODE_NUMBER: return 10;
      case QRMode.MODE_ALPHA_NUM: return 9;
      case QRMode.MODE_8BIT_BYTE: return 8;
      case QRMode.MODE_KANJI: return 8;
      default: throw new Error("mode:"+mode);
    }
  }else if(type<27){
    switch(mode){
      case QRMode.MODE_NUMBER: return 12;
      case QRMode.MODE_ALPHA_NUM: return 11;
      case QRMode.MODE_8BIT_BYTE: return 16;
      case QRMode.MODE_KANJI: return 10;
      default: throw new Error("mode:"+mode);
    }
  }else if(type<41){
    switch(mode){
      case QRMode.MODE_NUMBER: return 14;
      case QRMode.MODE_ALPHA_NUM: return 13;
      case QRMode.MODE_8BIT_BYTE: return 16;
      case QRMode.MODE_KANJI: return 12;
      default: throw new Error("mode:"+mode);
    }
  }else{
    throw new Error("typeNumber:"+type);
  }
},
getLostPoint:function(qr){
  var moduleCount=qr.getModuleCount();
  var lostPoint=0;

  // Level 1
  for(var row=0;row<moduleCount;row++){
    for(var col=0;col<moduleCount;col++){
      var sameCount=0;
      var dark=qr.isDark(row,col);
      for(var r=-1;r<=1;r++){
        if(row+r<0||moduleCount<=row+r) continue;
        for(var c=-1;c<=1;c++){
          if(col+c<0||moduleCount<=col+c) continue;
          if(r===0&&c===0) continue;
          if(dark===qr.isDark(row+r,col+c)) sameCount++;
        }
      }
      if(sameCount>5) lostPoint += (3 + sameCount - 5);
    }
  }

  // Level 2
  for(row=0;row<moduleCount-1;row++){
    for(col=0;col<moduleCount-1;col++){
      var count=0;
      if(qr.isDark(row,col)) count++;
      if(qr.isDark(row+1,col)) count++;
      if(qr.isDark(row,col+1)) count++;
      if(qr.isDark(row+1,col+1)) count++;
      if(count===0 || count===4) lostPoint += 3;
    }
  }

  // Level 3
  for(row=0;row<moduleCount;row++){
    for(col=0;col<moduleCount-6;col++){
      if(qr.isDark(row,col) && !qr.isDark(row,col+1) && qr.isDark(row,col+2) && qr.isDark(row,col+3) && qr.isDark(row,col+4) && !qr.isDark(row,col+5) && qr.isDark(row,col+6)){
        lostPoint += 40;
      }
    }
  }
  for(col=0;col<moduleCount;col++){
    for(row=0;row<moduleCount-6;row++){
      if(qr.isDark(row,col) && !qr.isDark(row+1,col) && qr.isDark(row+2,col) && qr.isDark(row+3,col) && qr.isDark(row+4,col) && !qr.isDark(row+5,col) && qr.isDark(row+6,col)){
        lostPoint += 40;
      }
    }
  }

  // Level 4
  var darkCount=0;
  for(col=0;col<moduleCount;col++){
    for(row=0;row<moduleCount;row++){
      if(qr.isDark(row,col)) darkCount++;
    }
  }
  var ratio = Math.abs(100*darkCount/moduleCount/moduleCount - 50) / 5;
  lostPoint += ratio * 10;

  return lostPoint;
}
};

function QRRSBlockImpl(){}
QRRSBlockImpl.getRSBlocks=function(typeNumber,errorCorrectLevel){
  var rsBlock = QRRSBlockImpl.getRsBlockTable(typeNumber,errorCorrectLevel);
  if(rsBlock===undefined) throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);
  var length = rsBlock.length/3;
  var list=[];
  for(var i=0;i<length;i++){
    var count = rsBlock[i*3+0];
    var totalCount = rsBlock[i*3+1];
    var dataCount = rsBlock[i*3+2];
    for(var j=0;j<count;j++) list.push(new QRRSBlock(totalCount,dataCount));
  }
  return list;
};
QRRSBlockImpl.getRsBlockTable=function(typeNumber,errorCorrectLevel){
  switch(errorCorrectLevel){
    case QRErrorCorrectLevel.L: return QRRSBlockImpl.RS_BLOCK_TABLE[(typeNumber-1)*4+0];
    case QRErrorCorrectLevel.M: return QRRSBlockImpl.RS_BLOCK_TABLE[(typeNumber-1)*4+1];
    case QRErrorCorrectLevel.Q: return QRRSBlockImpl.RS_BLOCK_TABLE[(typeNumber-1)*4+2];
    case QRErrorCorrectLevel.H: return QRRSBlockImpl.RS_BLOCK_TABLE[(typeNumber-1)*4+3];
    default: return undefined;
  }
};

// Full RS_BLOCK_TABLE (as you had)
QRRSBlockImpl.RS_BLOCK_TABLE = [
[1,26,19],[1,26,16],[1,26,13],[1,26,9],
[1,44,34],[1,44,28],[1,44,22],[1,44,16],
[1,70,55],[1,70,44],[2,35,17],[2,35,13],
[1,100,80],[2,50,32],[2,50,24],[4,25,9],
[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],
[2,86,68],[4,43,27],[4,43,19],[4,43,15],
[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],
[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],
[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],
[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],
[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],
[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],
[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],
[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],
[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],
[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],
[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],
[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],
[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],
[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],
[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],
[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],
[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],
[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],
[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],
[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],
[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],
[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],
[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],
[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],
[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],
[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],
[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],
[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],
[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],
[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],
[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],
[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],
[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],
[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]
];

var QRMathImpl = new QRMath();
QRMathImpl.glog=function(n){if(n<1) throw new Error("glog("+n+")"); return this.logTable[n];};
QRMathImpl.gexp=function(n){while(n<0) n+=255; while(n>=256) n-=255; return this.expTable[n];};
QRMathImpl.mul=function(a,b){if(a===0||b===0) return 0; return this.gexp(this.glog(a)+this.glog(b));};

function QRPolynomial(num,shift){
  this.num=num;
  this.shift=shift;
}
QRPolynomial.prototype.get=function(i){return this.num[i];};
QRPolynomial.prototype.getLength=function(){return this.num.length;};
QRPolynomial.prototype.multiply=function(e){
  var num=new Array(this.getLength()+e.getLength()-1);
  for(var i=0;i<num.length;i++) num[i]=0;
  for(i=0;i<this.getLength();i++){
    for(var j=0;j<e.getLength();j++){
      num[i+j]^=QRMathImpl.mul(this.get(i),e.get(j));
    }
  }
  return new QRPolynomial(num,0);
};
QRPolynomial.prototype.mod=function(e){
  if(this.getLength()-e.getLength()<0) return this;
  var ratio = QRMathImpl.glog(this.get(0)) - QRMathImpl.glog(e.get(0));
  var num = this.num.slice();
  for(var i=0;i<e.getLength();i++){
    num[i]^=QRMathImpl.gexp(QRMathImpl.glog(e.get(i)) + ratio);
  }
  // trim leading zeros
  var offset=0;
  while(offset<num.length && num[offset]===0) offset++;
  return new QRPolynomial(num.slice(offset),0).mod(e);
};

QRBitBuffer.prototype.getBuffer=function(){return this.buffer;};
QRBitBuffer.prototype.put=function(num,length){
  for(var i=0;i<length;i++){
    this.putBit(((num >>> (length-i-1)) & 1) === 1);
  }
};
QRBitBuffer.prototype.putBit=function(bit){
  var bufIndex = Math.floor(this.length / 8);
  if(this.buffer.length <= bufIndex) this.buffer.push(0);
  if(bit) this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
  this.length++;
};

QRCodeModel.prototype.addData=function(data){
  this.dataList.push(new QR8bitByte(data));
  this.dataCache=null;
};
QRCodeModel.prototype.isDark=function(row,col){
  if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col) throw new Error(row+","+col);
  return this.modules[row][col];
};
QRCodeModel.prototype.getModuleCount=function(){return this.moduleCount;};

// ✅ FIX: auto typeNumber must NOT decrement.
// ✅ FIX: auto typeNumber uses correct fit check.
QRCodeModel.prototype.make=function(){
  if(this.typeNumber < 1){
    this.typeNumber = 1;
    for(; this.typeNumber < 40; this.typeNumber++){
      var rsBlocks = QRRSBlockImpl.getRSBlocks(this.typeNumber, this.errorCorrectLevel);
      var buffer = new QRBitBuffer();

      for(var i=0;i<this.dataList.length;i++){
        var data = this.dataList[i];
        buffer.put(data.mode, 4);
        buffer.put(data.data.length, QRUtil.getLengthInBits(data.mode, this.typeNumber));
        data.write(buffer);
      }

      var totalDataCount = 0;
      for(i=0;i<rsBlocks.length;i++) totalDataCount += rsBlocks[i].dataCount;

      if(buffer.length <= totalDataCount * 8){
        break; // fits
      }
    }
  }
  this.makeImpl(false, this.getBestMaskPattern());
};

QRCodeModel.prototype.makeImpl=function(test, maskPattern){
  this.moduleCount = this.typeNumber * 4 + 17;
  this.modules = new Array(this.moduleCount);
  for(var row=0;row<this.moduleCount;row++){
    this.modules[row] = new Array(this.moduleCount);
    for(var col=0;col<this.moduleCount;col++) this.modules[row][col]=null;
  }

  this.setupPositionProbePattern(0,0);
  this.setupPositionProbePattern(this.moduleCount-7,0);
  this.setupPositionProbePattern(0,this.moduleCount-7);
  this.setupPositionAdjustPattern();
  this.setupTimingPattern();
  this.setupTypeInfo(test, maskPattern);
  if(this.typeNumber >= 7) this.setupTypeNumber(test);

  if(this.dataCache === null){
    this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  }
  this.mapData(this.dataCache, maskPattern);
};

QRCodeModel.prototype.setupPositionProbePattern=function(row,col){
  for(var r=-1;r<=7;r++){
    if(row+r<=-1||this.moduleCount<=row+r) continue;
    for(var c=-1;c<=7;c++){
      if(col+c<=-1||this.moduleCount<=col+c) continue;
      if((0<=r&&r<=6&&(c===0||c===6)) || (0<=c&&c<=6&&(r===0||r===6)) || (2<=r&&r<=4 && 2<=c&&c<=4)){
        this.modules[row+r][col+c]=true;
      }else{
        this.modules[row+r][col+c]=false;
      }
    }
  }
};

QRCodeModel.prototype.getBestMaskPattern=function(){
  var minLost=0;
  var pattern=0;
  for(var i=0;i<8;i++){
    this.makeImpl(true, i);
    var lost = QRUtil.getLostPoint(this);
    if(i===0 || lost < minLost){
      minLost = lost;
      pattern = i;
    }
  }
  return pattern;
};

QRCodeModel.prototype.setupTimingPattern=function(){
  for(var i=8;i<this.moduleCount-8;i++){
    if(this.modules[i][6]===null) this.modules[i][6] = (i%2===0);
    if(this.modules[6][i]===null) this.modules[6][i] = (i%2===0);
  }
};

QRCodeModel.prototype.setupPositionAdjustPattern=function(){
  var pos = QRUtil.getPatternPosition(this.typeNumber);
  for(var i=0;i<pos.length;i++){
    for(var j=0;j<pos.length;j++){
      var row = pos[i];
      var col = pos[j];
      if(this.modules[row][col] !== null) continue;
      for(var r=-2;r<=2;r++){
        for(var c=-2;c<=2;c++){
          this.modules[row+r][col+c] = (r===-2||r===2||c===-2||c===2 || (r===0 && c===0));
        }
      }
    }
  }
};

QRCodeModel.prototype.setupTypeNumber=function(test){
  var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
  for(var i=0;i<18;i++){
    var mod = (!test && ((bits >> i) & 1) === 1);
    this.modules[Math.floor(i/3)][i%3 + this.moduleCount - 8 - 3] = mod;
  }
  for(i=0;i<18;i++){
    mod = (!test && ((bits >> i) & 1) === 1);
    this.modules[i%3 + this.moduleCount - 8 - 3][Math.floor(i/3)] = mod;
  }
};

QRCodeModel.prototype.setupTypeInfo=function(test, maskPattern){
  var data = (this.errorCorrectLevel << 3) | maskPattern;
  var bits = QRUtil.getBCHTypeInfo(data);

  for(var i=0;i<15;i++){
    var mod = (!test && ((bits >> i) & 1) === 1);
    if(i<6) this.modules[i][8] = mod;
    else if(i<8) this.modules[i+1][8] = mod;
    else this.modules[this.moduleCount-15+i][8] = mod;
  }

  for(i=0;i<15;i++){
    mod = (!test && ((bits >> i) & 1) === 1);
    if(i<8) this.modules[8][this.moduleCount-i-1] = mod;
    else if(i<9) this.modules[8][15-i-1+1] = mod;
    else this.modules[8][15-i-1] = mod;
  }

  this.modules[this.moduleCount-8][8] = (!test);
};

QRCodeModel.prototype.mapData=function(data, maskPattern){
  var inc = -1;
  var row = this.moduleCount - 1;
  var bitIndex = 7;
  var byteIndex = 0;

  for(var col=this.moduleCount-1; col>0; col-=2){
    if(col===6) col--;
    while(true){
      for(var c=0;c<2;c++){
        if(this.modules[row][col-c] === null){
          var dark = false;
          if(byteIndex < data.length){
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
          }
          var mask = QRUtil.getMask(maskPattern, row, col-c);
          if(mask) dark = !dark;
          this.modules[row][col-c] = dark;
          bitIndex--;
          if(bitIndex === -1){
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if(row < 0 || this.moduleCount <= row){
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
};

// ✅ FIX: Proper RS/EC generation + interleaving.
QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){
  var rsBlocks = QRRSBlockImpl.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer = new QRBitBuffer();

  for(var i=0;i<dataList.length;i++){
    var data = dataList[i];
    buffer.put(data.mode, 4);
    buffer.put(data.data.length, QRUtil.getLengthInBits(data.mode, typeNumber));
    data.write(buffer);
  }

  var totalDataCount = 0;
  for(i=0;i<rsBlocks.length;i++) totalDataCount += rsBlocks[i].dataCount;

  // terminator
  if(buffer.length + 4 <= totalDataCount * 8) buffer.put(0,4);

  // pad to byte
  while(buffer.length % 8 !== 0) buffer.putBit(false);

  // pad bytes
  while(buffer.getBuffer().length < totalDataCount){
    buffer.put(0xEC, 8);
    if(buffer.getBuffer().length >= totalDataCount) break;
    buffer.put(0x11, 8);
  }

  return QRCodeModel.createBytes(buffer, rsBlocks);
};

QRCodeModel.createBytes=function(buffer, rsBlocks){
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;

  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);

  for(var r=0;r<rsBlocks.length;r++){
    var dcCount = rsBlocks[r].dataCount;
    var ecCount = rsBlocks[r].totalCount - dcCount;

    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);

    dcdata[r] = new Array(dcCount);
    for(var i=0;i<dcdata[r].length;i++){
      dcdata[r][i] = buffer.getBuffer()[i + offset];
    }
    offset += dcCount;

    var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength()-1);
    var modPoly = rawPoly.mod(rsPoly);

    ecdata[r] = new Array(ecCount);
    var modLen = modPoly.getLength();
    for(i=0;i<ecCount;i++){
      var modIndex = i + modLen - ecCount;
      ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
    }
  }

  // interleave
  var totalCodeCount = 0;
  for(r=0;r<rsBlocks.length;r++) totalCodeCount += rsBlocks[r].totalCount;

  var data = new Array(totalCodeCount);
  var index = 0;

  for(i=0;i<maxDcCount;i++){
    for(r=0;r<rsBlocks.length;r++){
      if(i < dcdata[r].length) data[index++] = dcdata[r][i];
    }
  }
  for(i=0;i<maxEcCount;i++){
    for(r=0;r<rsBlocks.length;r++){
      if(i < ecdata[r].length) data[index++] = ecdata[r][i];
    }
  }

  return data;
};

QR8bitByte.prototype.getLength=function(){return this.data.length;};
QR8bitByte.prototype.write=function(buffer){
  for(var i=0;i<this.data.length;i++){
    buffer.put(this.data.charCodeAt(i), 8);
  }
};

// Public QRCode wrapper (same API as before)
function QRCode(el){
  this._el = (typeof el === "string") ? document.getElementById(el) : el;
  this._htOption = {
    width: 256,
    height: 256,
    typeNumber: 0,            // ✅ default AUTO
    margin: 4,                // ✅ quiet zone in modules
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: QRErrorCorrectLevel.H
  };
}

QRCode.prototype.makeCode=function(text){
  this._oQRCode = new QRCodeModel(this._htOption.typeNumber, this._htOption.correctLevel);
  this._oQRCode.addData(text);
  this._oQRCode.make();

  this._el.title = text;
  this._el.innerHTML = "";
  this._el.appendChild(this._createCanvas());
};

QRCode.prototype._createCanvas=function(){
  var moduleCount = this._oQRCode.getModuleCount();
  var marginModules = Math.max(0, (this._htOption.margin|0));
  var totalModules = moduleCount + marginModules*2;

  var size = Math.min(this._htOption.width, this._htOption.height);
  // Make scale integer to avoid blur
  var scale = Math.floor(size / totalModules);
  if(scale < 1) scale = 1;

  var canvasSize = scale * totalModules;
  var canvas = document.createElement("canvas");
  canvas.width = canvasSize;
  canvas.height = canvasSize;

  var ctx = canvas.getContext("2d");
  ctx.fillStyle = this._htOption.colorLight;
  ctx.fillRect(0, 0, canvasSize, canvasSize);

  for(var r=0;r<moduleCount;r++){
    for(var c=0;c<moduleCount;c++){
      ctx.fillStyle = this._oQRCode.isDark(r,c) ? this._htOption.colorDark : this._htOption.colorLight;
      var x = (c + marginModules) * scale;
      var y = (r + marginModules) * scale;
      ctx.fillRect(x, y, scale, scale);
    }
  }

  return canvas;
};

window.QRCode = QRCode;
window.QRCodeCorrectLevel = QRErrorCorrectLevel;
})();
